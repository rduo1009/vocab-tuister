// Code generated by mkunion. DO NOT EDIT.
package search

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
)

type SearchCMDVisitor interface {
	VisitTerm(v *Term) any
	VisitFulltext(v *Fulltext) any
}

type SearchCMD interface {
	AcceptSearchCMD(g SearchCMDVisitor) any
}

var (
	_ SearchCMD = (*Term)(nil)
	_ SearchCMD = (*Fulltext)(nil)
)

func (r *Term) AcceptSearchCMD(v SearchCMDVisitor) any     { return v.VisitTerm(r) }
func (r *Fulltext) AcceptSearchCMD(v SearchCMDVisitor) any { return v.VisitFulltext(r) }

func MatchSearchCMDR3[T0, T1, T2 any](
	x SearchCMD,
	f1 func(x *Term) (T0, T1, T2),
	f2 func(x *Fulltext) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *Term:
		return f1(v)
	case *Fulltext:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchSearchCMDR2[T0, T1 any](
	x SearchCMD,
	f1 func(x *Term) (T0, T1),
	f2 func(x *Fulltext) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *Term:
		return f1(v)
	case *Fulltext:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchSearchCMDR1[T0 any](
	x SearchCMD,
	f1 func(x *Term) T0,
	f2 func(x *Fulltext) T0,
) T0 {
	switch v := x.(type) {
	case *Term:
		return f1(v)
	case *Fulltext:
		return f2(v)
	}
	var result1 T0
	return result1
}

func MatchSearchCMDR0(
	x SearchCMD,
	f1 func(x *Term),
	f2 func(x *Fulltext),
) {
	switch v := x.(type) {
	case *Term:
		f1(v)
	case *Fulltext:
		f2(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/search.Fulltext", FulltextFromJSON, FulltextToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/search.SearchCMD", SearchCMDFromJSON, SearchCMDToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/search.Term", TermFromJSON, TermToJSON)
}

type SearchCMDUnionJSON struct {
	Type     string          `json:"question_type,omitempty"`
	Term     json.RawMessage `json:"search.Term,omitempty"`
	Fulltext json.RawMessage `json:"search.Fulltext,omitempty"`
}

func SearchCMDFromJSON(x []byte) (SearchCMD, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data SearchCMDUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("search.SearchCMDFromJSON: %w", err)
	}

	switch data.Type {
	case "search.Term":
		return TermFromJSON(data.Term)
	case "search.Fulltext":
		return FulltextFromJSON(data.Fulltext)
	}

	if data.Term != nil {
		return TermFromJSON(data.Term)
	} else if data.Fulltext != nil {
		return FulltextFromJSON(data.Fulltext)
	}
	return nil, fmt.Errorf("search.SearchCMDFromJSON: unknown type: %s", data.Type)
}

func SearchCMDToJSON(x SearchCMD) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchSearchCMDR2(
		x,
		func(y *Term) ([]byte, error) {
			body, err := TermToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("search.SearchCMDToJSON: %w", err)
			}
			return json.Marshal(SearchCMDUnionJSON{
				Type: "search.Term",
				Term: body,
			})
		},
		func(y *Fulltext) ([]byte, error) {
			body, err := FulltextToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("search.SearchCMDToJSON: %w", err)
			}
			return json.Marshal(SearchCMDUnionJSON{
				Type:     "search.Fulltext",
				Fulltext: body,
			})
		},
	)
}

func TermFromJSON(x []byte) (*Term, error) {
	result := new(Term)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("search.TermFromJSON: %w", err)
	}
	return result, nil
}

func TermToJSON(x *Term) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Term)(nil)
	_ json.Marshaler   = (*Term)(nil)
)

func (r *Term) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONTerm(*r)
}
func (r *Term) _marshalJSONTerm(x Term) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldTerm []byte
	fieldTerm, err = r._marshalJSONstring(x.Term)
	if err != nil {
		return nil, fmt.Errorf("search: Term._marshalJSONTerm: field name Term; %w", err)
	}
	partial["Term"] = fieldTerm
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("search: Term._marshalJSONTerm: struct; %w", err)
	}
	return result, nil
}
func (r *Term) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("search: Term._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Term) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONTerm(data)
	if err != nil {
		return fmt.Errorf("search: Term.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Term) _unmarshalJSONTerm(data []byte) (Term, error) {
	result := Term{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("search: Term._unmarshalJSONTerm: native struct unwrap; %w", err)
	}
	if fieldTerm, ok := partial["Term"]; ok {
		result.Term, err = r._unmarshalJSONstring(fieldTerm)
		if err != nil {
			return result, fmt.Errorf("search: Term._unmarshalJSONTerm: field Term; %w", err)
		}
	}
	return result, nil
}
func (r *Term) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("search: Term._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}

func FulltextFromJSON(x []byte) (*Fulltext, error) {
	result := new(Fulltext)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("search.FulltextFromJSON: %w", err)
	}
	return result, nil
}

func FulltextToJSON(x *Fulltext) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Fulltext)(nil)
	_ json.Marshaler   = (*Fulltext)(nil)
)

func (r *Fulltext) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONFulltext(*r)
}
func (r *Fulltext) _marshalJSONFulltext(x Fulltext) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldQuery []byte
	fieldQuery, err = r._marshalJSONstring(x.Query)
	if err != nil {
		return nil, fmt.Errorf("search: Fulltext._marshalJSONFulltext: field name Query; %w", err)
	}
	partial["Query"] = fieldQuery
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("search: Fulltext._marshalJSONFulltext: struct; %w", err)
	}
	return result, nil
}
func (r *Fulltext) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("search: Fulltext._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Fulltext) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONFulltext(data)
	if err != nil {
		return fmt.Errorf("search: Fulltext.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Fulltext) _unmarshalJSONFulltext(data []byte) (Fulltext, error) {
	result := Fulltext{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("search: Fulltext._unmarshalJSONFulltext: native struct unwrap; %w", err)
	}
	if fieldQuery, ok := partial["Query"]; ok {
		result.Query, err = r._unmarshalJSONstring(fieldQuery)
		if err != nil {
			return result, fmt.Errorf("search: Fulltext._unmarshalJSONFulltext: field Query; %w", err)
		}
	}
	return result, nil
}
func (r *Fulltext) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("search: Fulltext._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
