// Code generated by mkunion. DO NOT EDIT.
package projection

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
)

type NodeVisitor interface {
	VisitDoWindow(v *DoWindow) any
	VisitDoMap(v *DoMap) any
	VisitDoLoad(v *DoLoad) any
	VisitDoJoin(v *DoJoin) any
}

type Node interface {
	AcceptNode(g NodeVisitor) any
}

var (
	_ Node = (*DoWindow)(nil)
	_ Node = (*DoMap)(nil)
	_ Node = (*DoLoad)(nil)
	_ Node = (*DoJoin)(nil)
)

func (r *DoWindow) AcceptNode(v NodeVisitor) any { return v.VisitDoWindow(r) }
func (r *DoMap) AcceptNode(v NodeVisitor) any    { return v.VisitDoMap(r) }
func (r *DoLoad) AcceptNode(v NodeVisitor) any   { return v.VisitDoLoad(r) }
func (r *DoJoin) AcceptNode(v NodeVisitor) any   { return v.VisitDoJoin(r) }

func MatchNodeR3[T0, T1, T2 any](
	x Node,
	f1 func(x *DoWindow) (T0, T1, T2),
	f2 func(x *DoMap) (T0, T1, T2),
	f3 func(x *DoLoad) (T0, T1, T2),
	f4 func(x *DoJoin) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *DoWindow:
		return f1(v)
	case *DoMap:
		return f2(v)
	case *DoLoad:
		return f3(v)
	case *DoJoin:
		return f4(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchNodeR2[T0, T1 any](
	x Node,
	f1 func(x *DoWindow) (T0, T1),
	f2 func(x *DoMap) (T0, T1),
	f3 func(x *DoLoad) (T0, T1),
	f4 func(x *DoJoin) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *DoWindow:
		return f1(v)
	case *DoMap:
		return f2(v)
	case *DoLoad:
		return f3(v)
	case *DoJoin:
		return f4(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchNodeR1[T0 any](
	x Node,
	f1 func(x *DoWindow) T0,
	f2 func(x *DoMap) T0,
	f3 func(x *DoLoad) T0,
	f4 func(x *DoJoin) T0,
) T0 {
	switch v := x.(type) {
	case *DoWindow:
		return f1(v)
	case *DoMap:
		return f2(v)
	case *DoLoad:
		return f3(v)
	case *DoJoin:
		return f4(v)
	}
	var result1 T0
	return result1
}

func MatchNodeR0(
	x Node,
	f1 func(x *DoWindow),
	f2 func(x *DoMap),
	f3 func(x *DoLoad),
	f4 func(x *DoJoin),
) {
	switch v := x.(type) {
	case *DoWindow:
		f1(v)
	case *DoMap:
		f2(v)
	case *DoLoad:
		f3(v)
	case *DoJoin:
		f4(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.DoJoin", DoJoinFromJSON, DoJoinToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.DoLoad", DoLoadFromJSON, DoLoadToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.DoMap", DoMapFromJSON, DoMapToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.DoWindow", DoWindowFromJSON, DoWindowToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.Node", NodeFromJSON, NodeToJSON)
}

type NodeUnionJSON struct {
	Type     string          `json:"question_type,omitempty"`
	DoWindow json.RawMessage `json:"projection.DoWindow,omitempty"`
	DoMap    json.RawMessage `json:"projection.DoMap,omitempty"`
	DoLoad   json.RawMessage `json:"projection.DoLoad,omitempty"`
	DoJoin   json.RawMessage `json:"projection.DoJoin,omitempty"`
}

func NodeFromJSON(x []byte) (Node, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data NodeUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("projection.NodeFromJSON: %w", err)
	}

	switch data.Type {
	case "projection.DoWindow":
		return DoWindowFromJSON(data.DoWindow)
	case "projection.DoMap":
		return DoMapFromJSON(data.DoMap)
	case "projection.DoLoad":
		return DoLoadFromJSON(data.DoLoad)
	case "projection.DoJoin":
		return DoJoinFromJSON(data.DoJoin)
	}

	if data.DoWindow != nil {
		return DoWindowFromJSON(data.DoWindow)
	} else if data.DoMap != nil {
		return DoMapFromJSON(data.DoMap)
	} else if data.DoLoad != nil {
		return DoLoadFromJSON(data.DoLoad)
	} else if data.DoJoin != nil {
		return DoJoinFromJSON(data.DoJoin)
	}
	return nil, fmt.Errorf("projection.NodeFromJSON: unknown type: %s", data.Type)
}

func NodeToJSON(x Node) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchNodeR2(
		x,
		func(y *DoWindow) ([]byte, error) {
			body, err := DoWindowToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("projection.NodeToJSON: %w", err)
			}
			return json.Marshal(NodeUnionJSON{
				Type:     "projection.DoWindow",
				DoWindow: body,
			})
		},
		func(y *DoMap) ([]byte, error) {
			body, err := DoMapToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("projection.NodeToJSON: %w", err)
			}
			return json.Marshal(NodeUnionJSON{
				Type:  "projection.DoMap",
				DoMap: body,
			})
		},
		func(y *DoLoad) ([]byte, error) {
			body, err := DoLoadToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("projection.NodeToJSON: %w", err)
			}
			return json.Marshal(NodeUnionJSON{
				Type:   "projection.DoLoad",
				DoLoad: body,
			})
		},
		func(y *DoJoin) ([]byte, error) {
			body, err := DoJoinToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("projection.NodeToJSON: %w", err)
			}
			return json.Marshal(NodeUnionJSON{
				Type:   "projection.DoJoin",
				DoJoin: body,
			})
		},
	)
}

func DoWindowFromJSON(x []byte) (*DoWindow, error) {
	result := new(DoWindow)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("projection.DoWindowFromJSON: %w", err)
	}
	return result, nil
}

func DoWindowToJSON(x *DoWindow) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*DoWindow)(nil)
	_ json.Marshaler   = (*DoWindow)(nil)
)

func (r *DoWindow) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONDoWindow(*r)
}
func (r *DoWindow) _marshalJSONDoWindow(x DoWindow) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldCtx []byte
	fieldCtx, err = r._marshalJSONPtrDefaultContext(x.Ctx)
	if err != nil {
		return nil, fmt.Errorf("projection: DoWindow._marshalJSONDoWindow: field name Ctx; %w", err)
	}
	if fieldCtx != nil {
		partial["Ctx"] = fieldCtx
	}
	var fieldInput []byte
	fieldInput, err = r._marshalJSONNode(x.Input)
	if err != nil {
		return nil, fmt.Errorf("projection: DoWindow._marshalJSONDoWindow: field name Input; %w", err)
	}
	partial["Input"] = fieldInput
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: DoWindow._marshalJSONDoWindow: struct; %w", err)
	}
	return result, nil
}
func (r *DoWindow) _marshalJSONPtrDefaultContext(x *DefaultContext) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return r._marshalJSONDefaultContext(*x)
}
func (r *DoWindow) _marshalJSONDefaultContext(x DefaultContext) ([]byte, error) {
	result, err := shared.JSONMarshal[DefaultContext](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoWindow._marshalJSONDefaultContext:; %w", err)
	}
	return result, nil
}
func (r *DoWindow) _marshalJSONNode(x Node) ([]byte, error) {
	result, err := shared.JSONMarshal[Node](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoWindow._marshalJSONNode:; %w", err)
	}
	return result, nil
}
func (r *DoWindow) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONDoWindow(data)
	if err != nil {
		return fmt.Errorf("projection: DoWindow.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *DoWindow) _unmarshalJSONDoWindow(data []byte) (DoWindow, error) {
	result := DoWindow{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: DoWindow._unmarshalJSONDoWindow: native struct unwrap; %w", err)
	}
	if fieldCtx, ok := partial["Ctx"]; ok {
		result.Ctx, err = r._unmarshalJSONPtrDefaultContext(fieldCtx)
		if err != nil {
			return result, fmt.Errorf("projection: DoWindow._unmarshalJSONDoWindow: field Ctx; %w", err)
		}
	}
	if fieldInput, ok := partial["Input"]; ok {
		result.Input, err = r._unmarshalJSONNode(fieldInput)
		if err != nil {
			return result, fmt.Errorf("projection: DoWindow._unmarshalJSONDoWindow: field Input; %w", err)
		}
	}
	return result, nil
}
func (r *DoWindow) _unmarshalJSONPtrDefaultContext(data []byte) (*DefaultContext, error) {
	if len(data) == 0 {
		return nil, nil
	}
	if string(data[:4]) == "null" {
		return nil, nil
	}
	result, err := r._unmarshalJSONDefaultContext(data)
	if err != nil {
		return nil, fmt.Errorf("projection: DoWindow._unmarshalJSONPtrDefaultContext: pointer; %w", err)
	}
	return &result, nil
}
func (r *DoWindow) _unmarshalJSONDefaultContext(data []byte) (DefaultContext, error) {
	result, err := shared.JSONUnmarshal[DefaultContext](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoWindow._unmarshalJSONDefaultContext: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *DoWindow) _unmarshalJSONNode(data []byte) (Node, error) {
	result, err := shared.JSONUnmarshal[Node](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoWindow._unmarshalJSONNode: native ref unwrap; %w", err)
	}
	return result, nil
}

func DoMapFromJSON(x []byte) (*DoMap, error) {
	result := new(DoMap)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("projection.DoMapFromJSON: %w", err)
	}
	return result, nil
}

func DoMapToJSON(x *DoMap) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*DoMap)(nil)
	_ json.Marshaler   = (*DoMap)(nil)
)

func (r *DoMap) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONDoMap(*r)
}
func (r *DoMap) _marshalJSONDoMap(x DoMap) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldCtx []byte
	fieldCtx, err = r._marshalJSONPtrDefaultContext(x.Ctx)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONDoMap: field name Ctx; %w", err)
	}
	if fieldCtx != nil {
		partial["Ctx"] = fieldCtx
	}
	var fieldOnMap []byte
	fieldOnMap, err = r._marshalJSONHandler(x.OnMap)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONDoMap: field name OnMap; %w", err)
	}
	partial["OnMap"] = fieldOnMap
	var fieldInput []byte
	fieldInput, err = r._marshalJSONNode(x.Input)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONDoMap: field name Input; %w", err)
	}
	partial["Input"] = fieldInput
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONDoMap: struct; %w", err)
	}
	return result, nil
}
func (r *DoMap) _marshalJSONPtrDefaultContext(x *DefaultContext) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return r._marshalJSONDefaultContext(*x)
}
func (r *DoMap) _marshalJSONDefaultContext(x DefaultContext) ([]byte, error) {
	result, err := shared.JSONMarshal[DefaultContext](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONDefaultContext:; %w", err)
	}
	return result, nil
}
func (r *DoMap) _marshalJSONHandler(x Handler) ([]byte, error) {
	result, err := shared.JSONMarshal[Handler](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONHandler:; %w", err)
	}
	return result, nil
}
func (r *DoMap) _marshalJSONNode(x Node) ([]byte, error) {
	result, err := shared.JSONMarshal[Node](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONNode:; %w", err)
	}
	return result, nil
}
func (r *DoMap) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONDoMap(data)
	if err != nil {
		return fmt.Errorf("projection: DoMap.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *DoMap) _unmarshalJSONDoMap(data []byte) (DoMap, error) {
	result := DoMap{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: DoMap._unmarshalJSONDoMap: native struct unwrap; %w", err)
	}
	if fieldCtx, ok := partial["Ctx"]; ok {
		result.Ctx, err = r._unmarshalJSONPtrDefaultContext(fieldCtx)
		if err != nil {
			return result, fmt.Errorf("projection: DoMap._unmarshalJSONDoMap: field Ctx; %w", err)
		}
	}
	if fieldOnMap, ok := partial["OnMap"]; ok {
		result.OnMap, err = r._unmarshalJSONHandler(fieldOnMap)
		if err != nil {
			return result, fmt.Errorf("projection: DoMap._unmarshalJSONDoMap: field OnMap; %w", err)
		}
	}
	if fieldInput, ok := partial["Input"]; ok {
		result.Input, err = r._unmarshalJSONNode(fieldInput)
		if err != nil {
			return result, fmt.Errorf("projection: DoMap._unmarshalJSONDoMap: field Input; %w", err)
		}
	}
	return result, nil
}
func (r *DoMap) _unmarshalJSONPtrDefaultContext(data []byte) (*DefaultContext, error) {
	if len(data) == 0 {
		return nil, nil
	}
	if string(data[:4]) == "null" {
		return nil, nil
	}
	result, err := r._unmarshalJSONDefaultContext(data)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._unmarshalJSONPtrDefaultContext: pointer; %w", err)
	}
	return &result, nil
}
func (r *DoMap) _unmarshalJSONDefaultContext(data []byte) (DefaultContext, error) {
	result, err := shared.JSONUnmarshal[DefaultContext](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoMap._unmarshalJSONDefaultContext: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *DoMap) _unmarshalJSONHandler(data []byte) (Handler, error) {
	result, err := shared.JSONUnmarshal[Handler](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoMap._unmarshalJSONHandler: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *DoMap) _unmarshalJSONNode(data []byte) (Node, error) {
	result, err := shared.JSONUnmarshal[Node](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoMap._unmarshalJSONNode: native ref unwrap; %w", err)
	}
	return result, nil
}

func DoLoadFromJSON(x []byte) (*DoLoad, error) {
	result := new(DoLoad)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("projection.DoLoadFromJSON: %w", err)
	}
	return result, nil
}

func DoLoadToJSON(x *DoLoad) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*DoLoad)(nil)
	_ json.Marshaler   = (*DoLoad)(nil)
)

func (r *DoLoad) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONDoLoad(*r)
}
func (r *DoLoad) _marshalJSONDoLoad(x DoLoad) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldCtx []byte
	fieldCtx, err = r._marshalJSONPtrDefaultContext(x.Ctx)
	if err != nil {
		return nil, fmt.Errorf("projection: DoLoad._marshalJSONDoLoad: field name Ctx; %w", err)
	}
	if fieldCtx != nil {
		partial["Ctx"] = fieldCtx
	}
	var fieldOnLoad []byte
	fieldOnLoad, err = r._marshalJSONHandler(x.OnLoad)
	if err != nil {
		return nil, fmt.Errorf("projection: DoLoad._marshalJSONDoLoad: field name OnLoad; %w", err)
	}
	partial["OnLoad"] = fieldOnLoad
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: DoLoad._marshalJSONDoLoad: struct; %w", err)
	}
	return result, nil
}
func (r *DoLoad) _marshalJSONPtrDefaultContext(x *DefaultContext) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return r._marshalJSONDefaultContext(*x)
}
func (r *DoLoad) _marshalJSONDefaultContext(x DefaultContext) ([]byte, error) {
	result, err := shared.JSONMarshal[DefaultContext](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoLoad._marshalJSONDefaultContext:; %w", err)
	}
	return result, nil
}
func (r *DoLoad) _marshalJSONHandler(x Handler) ([]byte, error) {
	result, err := shared.JSONMarshal[Handler](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoLoad._marshalJSONHandler:; %w", err)
	}
	return result, nil
}
func (r *DoLoad) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONDoLoad(data)
	if err != nil {
		return fmt.Errorf("projection: DoLoad.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *DoLoad) _unmarshalJSONDoLoad(data []byte) (DoLoad, error) {
	result := DoLoad{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: DoLoad._unmarshalJSONDoLoad: native struct unwrap; %w", err)
	}
	if fieldCtx, ok := partial["Ctx"]; ok {
		result.Ctx, err = r._unmarshalJSONPtrDefaultContext(fieldCtx)
		if err != nil {
			return result, fmt.Errorf("projection: DoLoad._unmarshalJSONDoLoad: field Ctx; %w", err)
		}
	}
	if fieldOnLoad, ok := partial["OnLoad"]; ok {
		result.OnLoad, err = r._unmarshalJSONHandler(fieldOnLoad)
		if err != nil {
			return result, fmt.Errorf("projection: DoLoad._unmarshalJSONDoLoad: field OnLoad; %w", err)
		}
	}
	return result, nil
}
func (r *DoLoad) _unmarshalJSONPtrDefaultContext(data []byte) (*DefaultContext, error) {
	if len(data) == 0 {
		return nil, nil
	}
	if string(data[:4]) == "null" {
		return nil, nil
	}
	result, err := r._unmarshalJSONDefaultContext(data)
	if err != nil {
		return nil, fmt.Errorf("projection: DoLoad._unmarshalJSONPtrDefaultContext: pointer; %w", err)
	}
	return &result, nil
}
func (r *DoLoad) _unmarshalJSONDefaultContext(data []byte) (DefaultContext, error) {
	result, err := shared.JSONUnmarshal[DefaultContext](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoLoad._unmarshalJSONDefaultContext: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *DoLoad) _unmarshalJSONHandler(data []byte) (Handler, error) {
	result, err := shared.JSONUnmarshal[Handler](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoLoad._unmarshalJSONHandler: native ref unwrap; %w", err)
	}
	return result, nil
}

func DoJoinFromJSON(x []byte) (*DoJoin, error) {
	result := new(DoJoin)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("projection.DoJoinFromJSON: %w", err)
	}
	return result, nil
}

func DoJoinToJSON(x *DoJoin) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*DoJoin)(nil)
	_ json.Marshaler   = (*DoJoin)(nil)
)

func (r *DoJoin) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONDoJoin(*r)
}
func (r *DoJoin) _marshalJSONDoJoin(x DoJoin) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldCtx []byte
	fieldCtx, err = r._marshalJSONPtrDefaultContext(x.Ctx)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._marshalJSONDoJoin: field name Ctx; %w", err)
	}
	if fieldCtx != nil {
		partial["Ctx"] = fieldCtx
	}
	var fieldInput []byte
	fieldInput, err = r._marshalJSONSliceNode(x.Input)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._marshalJSONDoJoin: field name Input; %w", err)
	}
	partial["Input"] = fieldInput
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._marshalJSONDoJoin: struct; %w", err)
	}
	return result, nil
}
func (r *DoJoin) _marshalJSONPtrDefaultContext(x *DefaultContext) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return r._marshalJSONDefaultContext(*x)
}
func (r *DoJoin) _marshalJSONDefaultContext(x DefaultContext) ([]byte, error) {
	result, err := shared.JSONMarshal[DefaultContext](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._marshalJSONDefaultContext:; %w", err)
	}
	return result, nil
}
func (r *DoJoin) _marshalJSONSliceNode(x []Node) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONNode(v)
		if err != nil {
			return nil, fmt.Errorf("projection: DoJoin._marshalJSONSliceNode: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._marshalJSONSliceNode:; %w", err)
	}
	return result, nil
}
func (r *DoJoin) _marshalJSONNode(x Node) ([]byte, error) {
	result, err := shared.JSONMarshal[Node](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._marshalJSONNode:; %w", err)
	}
	return result, nil
}
func (r *DoJoin) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONDoJoin(data)
	if err != nil {
		return fmt.Errorf("projection: DoJoin.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *DoJoin) _unmarshalJSONDoJoin(data []byte) (DoJoin, error) {
	result := DoJoin{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: DoJoin._unmarshalJSONDoJoin: native struct unwrap; %w", err)
	}
	if fieldCtx, ok := partial["Ctx"]; ok {
		result.Ctx, err = r._unmarshalJSONPtrDefaultContext(fieldCtx)
		if err != nil {
			return result, fmt.Errorf("projection: DoJoin._unmarshalJSONDoJoin: field Ctx; %w", err)
		}
	}
	if fieldInput, ok := partial["Input"]; ok {
		result.Input, err = r._unmarshalJSONSliceNode(fieldInput)
		if err != nil {
			return result, fmt.Errorf("projection: DoJoin._unmarshalJSONDoJoin: field Input; %w", err)
		}
	}
	return result, nil
}
func (r *DoJoin) _unmarshalJSONPtrDefaultContext(data []byte) (*DefaultContext, error) {
	if len(data) == 0 {
		return nil, nil
	}
	if string(data[:4]) == "null" {
		return nil, nil
	}
	result, err := r._unmarshalJSONDefaultContext(data)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._unmarshalJSONPtrDefaultContext: pointer; %w", err)
	}
	return &result, nil
}
func (r *DoJoin) _unmarshalJSONDefaultContext(data []byte) (DefaultContext, error) {
	result, err := shared.JSONUnmarshal[DefaultContext](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoJoin._unmarshalJSONDefaultContext: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *DoJoin) _unmarshalJSONSliceNode(data []byte) ([]Node, error) {
	result := make([]Node, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: DoJoin._unmarshalJSONSliceNode: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONNode(v)
		if err != nil {
			return result, fmt.Errorf("projection: DoJoin._unmarshalJSONSliceNode: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *DoJoin) _unmarshalJSONNode(data []byte) (Node, error) {
	result, err := shared.JSONUnmarshal[Node](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoJoin._unmarshalJSONNode: native ref unwrap; %w", err)
	}
	return result, nil
}
