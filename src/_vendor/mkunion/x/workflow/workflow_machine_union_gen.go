// Code generated by mkunion. DO NOT EDIT.
package workflow

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/schema"
	"github.com/widmogrod/mkunion/x/shared"
)

type CommandVisitor interface {
	VisitRun(v *Run) any
	VisitCallback(v *Callback) any
	VisitTryRecover(v *TryRecover) any
	VisitStopSchedule(v *StopSchedule) any
	VisitResumeSchedule(v *ResumeSchedule) any
	VisitExpireAsync(v *ExpireAsync) any
}

type Command interface {
	AcceptCommand(g CommandVisitor) any
}

var (
	_ Command = (*Run)(nil)
	_ Command = (*Callback)(nil)
	_ Command = (*TryRecover)(nil)
	_ Command = (*StopSchedule)(nil)
	_ Command = (*ResumeSchedule)(nil)
	_ Command = (*ExpireAsync)(nil)
)

func (r *Run) AcceptCommand(v CommandVisitor) any            { return v.VisitRun(r) }
func (r *Callback) AcceptCommand(v CommandVisitor) any       { return v.VisitCallback(r) }
func (r *TryRecover) AcceptCommand(v CommandVisitor) any     { return v.VisitTryRecover(r) }
func (r *StopSchedule) AcceptCommand(v CommandVisitor) any   { return v.VisitStopSchedule(r) }
func (r *ResumeSchedule) AcceptCommand(v CommandVisitor) any { return v.VisitResumeSchedule(r) }
func (r *ExpireAsync) AcceptCommand(v CommandVisitor) any    { return v.VisitExpireAsync(r) }

func MatchCommandR3[T0, T1, T2 any](
	x Command,
	f1 func(x *Run) (T0, T1, T2),
	f2 func(x *Callback) (T0, T1, T2),
	f3 func(x *TryRecover) (T0, T1, T2),
	f4 func(x *StopSchedule) (T0, T1, T2),
	f5 func(x *ResumeSchedule) (T0, T1, T2),
	f6 func(x *ExpireAsync) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *Run:
		return f1(v)
	case *Callback:
		return f2(v)
	case *TryRecover:
		return f3(v)
	case *StopSchedule:
		return f4(v)
	case *ResumeSchedule:
		return f5(v)
	case *ExpireAsync:
		return f6(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchCommandR2[T0, T1 any](
	x Command,
	f1 func(x *Run) (T0, T1),
	f2 func(x *Callback) (T0, T1),
	f3 func(x *TryRecover) (T0, T1),
	f4 func(x *StopSchedule) (T0, T1),
	f5 func(x *ResumeSchedule) (T0, T1),
	f6 func(x *ExpireAsync) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *Run:
		return f1(v)
	case *Callback:
		return f2(v)
	case *TryRecover:
		return f3(v)
	case *StopSchedule:
		return f4(v)
	case *ResumeSchedule:
		return f5(v)
	case *ExpireAsync:
		return f6(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchCommandR1[T0 any](
	x Command,
	f1 func(x *Run) T0,
	f2 func(x *Callback) T0,
	f3 func(x *TryRecover) T0,
	f4 func(x *StopSchedule) T0,
	f5 func(x *ResumeSchedule) T0,
	f6 func(x *ExpireAsync) T0,
) T0 {
	switch v := x.(type) {
	case *Run:
		return f1(v)
	case *Callback:
		return f2(v)
	case *TryRecover:
		return f3(v)
	case *StopSchedule:
		return f4(v)
	case *ResumeSchedule:
		return f5(v)
	case *ExpireAsync:
		return f6(v)
	}
	var result1 T0
	return result1
}

func MatchCommandR0(
	x Command,
	f1 func(x *Run),
	f2 func(x *Callback),
	f3 func(x *TryRecover),
	f4 func(x *StopSchedule),
	f5 func(x *ResumeSchedule),
	f6 func(x *ExpireAsync),
) {
	switch v := x.(type) {
	case *Run:
		f1(v)
	case *Callback:
		f2(v)
	case *TryRecover:
		f3(v)
	case *StopSchedule:
		f4(v)
	case *ResumeSchedule:
		f5(v)
	case *ExpireAsync:
		f6(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Callback", CallbackFromJSON, CallbackToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Command", CommandFromJSON, CommandToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.ExpireAsync", ExpireAsyncFromJSON, ExpireAsyncToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.ResumeSchedule", ResumeScheduleFromJSON, ResumeScheduleToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Run", RunFromJSON, RunToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.StopSchedule", StopScheduleFromJSON, StopScheduleToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.TryRecover", TryRecoverFromJSON, TryRecoverToJSON)
}

type CommandUnionJSON struct {
	Type           string          `json:"question_type,omitempty"`
	Run            json.RawMessage `json:"workflow.Run,omitempty"`
	Callback       json.RawMessage `json:"workflow.Callback,omitempty"`
	TryRecover     json.RawMessage `json:"workflow.TryRecover,omitempty"`
	StopSchedule   json.RawMessage `json:"workflow.StopSchedule,omitempty"`
	ResumeSchedule json.RawMessage `json:"workflow.ResumeSchedule,omitempty"`
	ExpireAsync    json.RawMessage `json:"workflow.ExpireAsync,omitempty"`
}

func CommandFromJSON(x []byte) (Command, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data CommandUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("workflow.CommandFromJSON: %w", err)
	}

	switch data.Type {
	case "workflow.Run":
		return RunFromJSON(data.Run)
	case "workflow.Callback":
		return CallbackFromJSON(data.Callback)
	case "workflow.TryRecover":
		return TryRecoverFromJSON(data.TryRecover)
	case "workflow.StopSchedule":
		return StopScheduleFromJSON(data.StopSchedule)
	case "workflow.ResumeSchedule":
		return ResumeScheduleFromJSON(data.ResumeSchedule)
	case "workflow.ExpireAsync":
		return ExpireAsyncFromJSON(data.ExpireAsync)
	}

	if data.Run != nil {
		return RunFromJSON(data.Run)
	} else if data.Callback != nil {
		return CallbackFromJSON(data.Callback)
	} else if data.TryRecover != nil {
		return TryRecoverFromJSON(data.TryRecover)
	} else if data.StopSchedule != nil {
		return StopScheduleFromJSON(data.StopSchedule)
	} else if data.ResumeSchedule != nil {
		return ResumeScheduleFromJSON(data.ResumeSchedule)
	} else if data.ExpireAsync != nil {
		return ExpireAsyncFromJSON(data.ExpireAsync)
	}
	return nil, fmt.Errorf("workflow.CommandFromJSON: unknown type: %s", data.Type)
}

func CommandToJSON(x Command) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchCommandR2(
		x,
		func(y *Run) ([]byte, error) {
			body, err := RunToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.CommandToJSON: %w", err)
			}
			return json.Marshal(CommandUnionJSON{
				Type: "workflow.Run",
				Run:  body,
			})
		},
		func(y *Callback) ([]byte, error) {
			body, err := CallbackToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.CommandToJSON: %w", err)
			}
			return json.Marshal(CommandUnionJSON{
				Type:     "workflow.Callback",
				Callback: body,
			})
		},
		func(y *TryRecover) ([]byte, error) {
			body, err := TryRecoverToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.CommandToJSON: %w", err)
			}
			return json.Marshal(CommandUnionJSON{
				Type:       "workflow.TryRecover",
				TryRecover: body,
			})
		},
		func(y *StopSchedule) ([]byte, error) {
			body, err := StopScheduleToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.CommandToJSON: %w", err)
			}
			return json.Marshal(CommandUnionJSON{
				Type:         "workflow.StopSchedule",
				StopSchedule: body,
			})
		},
		func(y *ResumeSchedule) ([]byte, error) {
			body, err := ResumeScheduleToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.CommandToJSON: %w", err)
			}
			return json.Marshal(CommandUnionJSON{
				Type:           "workflow.ResumeSchedule",
				ResumeSchedule: body,
			})
		},
		func(y *ExpireAsync) ([]byte, error) {
			body, err := ExpireAsyncToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.CommandToJSON: %w", err)
			}
			return json.Marshal(CommandUnionJSON{
				Type:        "workflow.ExpireAsync",
				ExpireAsync: body,
			})
		},
	)
}

func RunFromJSON(x []byte) (*Run, error) {
	result := new(Run)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.RunFromJSON: %w", err)
	}
	return result, nil
}

func RunToJSON(x *Run) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Run)(nil)
	_ json.Marshaler   = (*Run)(nil)
)

func (r *Run) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONRun(*r)
}
func (r *Run) _marshalJSONRun(x Run) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldFlow []byte
	fieldFlow, err = r._marshalJSONWorkflow(x.Flow)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONRun: field name Flow; %w", err)
	}
	partial["Flow"] = fieldFlow
	var fieldInput []byte
	fieldInput, err = r._marshalJSONschema_Schema(x.Input)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONRun: field name Input; %w", err)
	}
	partial["Input"] = fieldInput
	var fieldRunOption []byte
	fieldRunOption, err = r._marshalJSONRunOption(x.RunOption)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONRun: field name RunOption; %w", err)
	}
	partial["RunOption"] = fieldRunOption
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONRun: struct; %w", err)
	}
	return result, nil
}
func (r *Run) _marshalJSONWorkflow(x Workflow) ([]byte, error) {
	result, err := shared.JSONMarshal[Workflow](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONWorkflow:; %w", err)
	}
	return result, nil
}
func (r *Run) _marshalJSONschema_Schema(x schema.Schema) ([]byte, error) {
	result, err := shared.JSONMarshal[schema.Schema](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONschema_Schema:; %w", err)
	}
	return result, nil
}
func (r *Run) _marshalJSONRunOption(x RunOption) ([]byte, error) {
	result, err := shared.JSONMarshal[RunOption](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONRunOption:; %w", err)
	}
	return result, nil
}
func (r *Run) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONRun(data)
	if err != nil {
		return fmt.Errorf("workflow: Run.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Run) _unmarshalJSONRun(data []byte) (Run, error) {
	result := Run{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Run._unmarshalJSONRun: native struct unwrap; %w", err)
	}
	if fieldFlow, ok := partial["Flow"]; ok {
		result.Flow, err = r._unmarshalJSONWorkflow(fieldFlow)
		if err != nil {
			return result, fmt.Errorf("workflow: Run._unmarshalJSONRun: field Flow; %w", err)
		}
	}
	if fieldInput, ok := partial["Input"]; ok {
		result.Input, err = r._unmarshalJSONschema_Schema(fieldInput)
		if err != nil {
			return result, fmt.Errorf("workflow: Run._unmarshalJSONRun: field Input; %w", err)
		}
	}
	if fieldRunOption, ok := partial["RunOption"]; ok {
		result.RunOption, err = r._unmarshalJSONRunOption(fieldRunOption)
		if err != nil {
			return result, fmt.Errorf("workflow: Run._unmarshalJSONRun: field RunOption; %w", err)
		}
	}
	return result, nil
}
func (r *Run) _unmarshalJSONWorkflow(data []byte) (Workflow, error) {
	result, err := shared.JSONUnmarshal[Workflow](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Run._unmarshalJSONWorkflow: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *Run) _unmarshalJSONschema_Schema(data []byte) (schema.Schema, error) {
	result, err := shared.JSONUnmarshal[schema.Schema](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Run._unmarshalJSONschema_Schema: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *Run) _unmarshalJSONRunOption(data []byte) (RunOption, error) {
	result, err := shared.JSONUnmarshal[RunOption](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Run._unmarshalJSONRunOption: native ref unwrap; %w", err)
	}
	return result, nil
}

func CallbackFromJSON(x []byte) (*Callback, error) {
	result := new(Callback)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.CallbackFromJSON: %w", err)
	}
	return result, nil
}

func CallbackToJSON(x *Callback) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Callback)(nil)
	_ json.Marshaler   = (*Callback)(nil)
)

func (r *Callback) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONCallback(*r)
}
func (r *Callback) _marshalJSONCallback(x Callback) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldCallbackID []byte
	fieldCallbackID, err = r._marshalJSONstring(x.CallbackID)
	if err != nil {
		return nil, fmt.Errorf("workflow: Callback._marshalJSONCallback: field name CallbackID; %w", err)
	}
	partial["CallbackID"] = fieldCallbackID
	var fieldResult []byte
	fieldResult, err = r._marshalJSONschema_Schema(x.Result)
	if err != nil {
		return nil, fmt.Errorf("workflow: Callback._marshalJSONCallback: field name Result; %w", err)
	}
	partial["Result"] = fieldResult
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Callback._marshalJSONCallback: struct; %w", err)
	}
	return result, nil
}
func (r *Callback) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Callback._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Callback) _marshalJSONschema_Schema(x schema.Schema) ([]byte, error) {
	result, err := shared.JSONMarshal[schema.Schema](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Callback._marshalJSONschema_Schema:; %w", err)
	}
	return result, nil
}
func (r *Callback) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONCallback(data)
	if err != nil {
		return fmt.Errorf("workflow: Callback.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Callback) _unmarshalJSONCallback(data []byte) (Callback, error) {
	result := Callback{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Callback._unmarshalJSONCallback: native struct unwrap; %w", err)
	}
	if fieldCallbackID, ok := partial["CallbackID"]; ok {
		result.CallbackID, err = r._unmarshalJSONstring(fieldCallbackID)
		if err != nil {
			return result, fmt.Errorf("workflow: Callback._unmarshalJSONCallback: field CallbackID; %w", err)
		}
	}
	if fieldResult, ok := partial["Result"]; ok {
		result.Result, err = r._unmarshalJSONschema_Schema(fieldResult)
		if err != nil {
			return result, fmt.Errorf("workflow: Callback._unmarshalJSONCallback: field Result; %w", err)
		}
	}
	return result, nil
}
func (r *Callback) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Callback._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *Callback) _unmarshalJSONschema_Schema(data []byte) (schema.Schema, error) {
	result, err := shared.JSONUnmarshal[schema.Schema](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Callback._unmarshalJSONschema_Schema: native ref unwrap; %w", err)
	}
	return result, nil
}

func TryRecoverFromJSON(x []byte) (*TryRecover, error) {
	result := new(TryRecover)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.TryRecoverFromJSON: %w", err)
	}
	return result, nil
}

func TryRecoverToJSON(x *TryRecover) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*TryRecover)(nil)
	_ json.Marshaler   = (*TryRecover)(nil)
)

func (r *TryRecover) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONTryRecover(*r)
}
func (r *TryRecover) _marshalJSONTryRecover(x TryRecover) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldRunID []byte
	fieldRunID, err = r._marshalJSONRunID(x.RunID)
	if err != nil {
		return nil, fmt.Errorf("workflow: TryRecover._marshalJSONTryRecover: field name RunID; %w", err)
	}
	partial["RunID"] = fieldRunID
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: TryRecover._marshalJSONTryRecover: struct; %w", err)
	}
	return result, nil
}
func (r *TryRecover) _marshalJSONRunID(x RunID) ([]byte, error) {
	result, err := shared.JSONMarshal[RunID](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: TryRecover._marshalJSONRunID:; %w", err)
	}
	return result, nil
}
func (r *TryRecover) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONTryRecover(data)
	if err != nil {
		return fmt.Errorf("workflow: TryRecover.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *TryRecover) _unmarshalJSONTryRecover(data []byte) (TryRecover, error) {
	result := TryRecover{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: TryRecover._unmarshalJSONTryRecover: native struct unwrap; %w", err)
	}
	if fieldRunID, ok := partial["RunID"]; ok {
		result.RunID, err = r._unmarshalJSONRunID(fieldRunID)
		if err != nil {
			return result, fmt.Errorf("workflow: TryRecover._unmarshalJSONTryRecover: field RunID; %w", err)
		}
	}
	return result, nil
}
func (r *TryRecover) _unmarshalJSONRunID(data []byte) (RunID, error) {
	result, err := shared.JSONUnmarshal[RunID](data)
	if err != nil {
		return result, fmt.Errorf("workflow: TryRecover._unmarshalJSONRunID: native ref unwrap; %w", err)
	}
	return result, nil
}

func StopScheduleFromJSON(x []byte) (*StopSchedule, error) {
	result := new(StopSchedule)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.StopScheduleFromJSON: %w", err)
	}
	return result, nil
}

func StopScheduleToJSON(x *StopSchedule) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*StopSchedule)(nil)
	_ json.Marshaler   = (*StopSchedule)(nil)
)

func (r *StopSchedule) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONStopSchedule(*r)
}
func (r *StopSchedule) _marshalJSONStopSchedule(x StopSchedule) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldParentRunID []byte
	fieldParentRunID, err = r._marshalJSONRunID(x.ParentRunID)
	if err != nil {
		return nil, fmt.Errorf("workflow: StopSchedule._marshalJSONStopSchedule: field name ParentRunID; %w", err)
	}
	partial["ParentRunID"] = fieldParentRunID
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: StopSchedule._marshalJSONStopSchedule: struct; %w", err)
	}
	return result, nil
}
func (r *StopSchedule) _marshalJSONRunID(x RunID) ([]byte, error) {
	result, err := shared.JSONMarshal[RunID](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: StopSchedule._marshalJSONRunID:; %w", err)
	}
	return result, nil
}
func (r *StopSchedule) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONStopSchedule(data)
	if err != nil {
		return fmt.Errorf("workflow: StopSchedule.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *StopSchedule) _unmarshalJSONStopSchedule(data []byte) (StopSchedule, error) {
	result := StopSchedule{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: StopSchedule._unmarshalJSONStopSchedule: native struct unwrap; %w", err)
	}
	if fieldParentRunID, ok := partial["ParentRunID"]; ok {
		result.ParentRunID, err = r._unmarshalJSONRunID(fieldParentRunID)
		if err != nil {
			return result, fmt.Errorf("workflow: StopSchedule._unmarshalJSONStopSchedule: field ParentRunID; %w", err)
		}
	}
	return result, nil
}
func (r *StopSchedule) _unmarshalJSONRunID(data []byte) (RunID, error) {
	result, err := shared.JSONUnmarshal[RunID](data)
	if err != nil {
		return result, fmt.Errorf("workflow: StopSchedule._unmarshalJSONRunID: native ref unwrap; %w", err)
	}
	return result, nil
}

func ResumeScheduleFromJSON(x []byte) (*ResumeSchedule, error) {
	result := new(ResumeSchedule)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.ResumeScheduleFromJSON: %w", err)
	}
	return result, nil
}

func ResumeScheduleToJSON(x *ResumeSchedule) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*ResumeSchedule)(nil)
	_ json.Marshaler   = (*ResumeSchedule)(nil)
)

func (r *ResumeSchedule) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONResumeSchedule(*r)
}
func (r *ResumeSchedule) _marshalJSONResumeSchedule(x ResumeSchedule) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldParentRunID []byte
	fieldParentRunID, err = r._marshalJSONRunID(x.ParentRunID)
	if err != nil {
		return nil, fmt.Errorf("workflow: ResumeSchedule._marshalJSONResumeSchedule: field name ParentRunID; %w", err)
	}
	partial["ParentRunID"] = fieldParentRunID
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: ResumeSchedule._marshalJSONResumeSchedule: struct; %w", err)
	}
	return result, nil
}
func (r *ResumeSchedule) _marshalJSONRunID(x RunID) ([]byte, error) {
	result, err := shared.JSONMarshal[RunID](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: ResumeSchedule._marshalJSONRunID:; %w", err)
	}
	return result, nil
}
func (r *ResumeSchedule) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONResumeSchedule(data)
	if err != nil {
		return fmt.Errorf("workflow: ResumeSchedule.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *ResumeSchedule) _unmarshalJSONResumeSchedule(data []byte) (ResumeSchedule, error) {
	result := ResumeSchedule{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: ResumeSchedule._unmarshalJSONResumeSchedule: native struct unwrap; %w", err)
	}
	if fieldParentRunID, ok := partial["ParentRunID"]; ok {
		result.ParentRunID, err = r._unmarshalJSONRunID(fieldParentRunID)
		if err != nil {
			return result, fmt.Errorf("workflow: ResumeSchedule._unmarshalJSONResumeSchedule: field ParentRunID; %w", err)
		}
	}
	return result, nil
}
func (r *ResumeSchedule) _unmarshalJSONRunID(data []byte) (RunID, error) {
	result, err := shared.JSONUnmarshal[RunID](data)
	if err != nil {
		return result, fmt.Errorf("workflow: ResumeSchedule._unmarshalJSONRunID: native ref unwrap; %w", err)
	}
	return result, nil
}

func ExpireAsyncFromJSON(x []byte) (*ExpireAsync, error) {
	result := new(ExpireAsync)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.ExpireAsyncFromJSON: %w", err)
	}
	return result, nil
}

func ExpireAsyncToJSON(x *ExpireAsync) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*ExpireAsync)(nil)
	_ json.Marshaler   = (*ExpireAsync)(nil)
)

func (r *ExpireAsync) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONExpireAsync(*r)
}
func (r *ExpireAsync) _marshalJSONExpireAsync(x ExpireAsync) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldRunID []byte
	fieldRunID, err = r._marshalJSONRunID(x.RunID)
	if err != nil {
		return nil, fmt.Errorf("workflow: ExpireAsync._marshalJSONExpireAsync: field name RunID; %w", err)
	}
	partial["RunID"] = fieldRunID
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: ExpireAsync._marshalJSONExpireAsync: struct; %w", err)
	}
	return result, nil
}
func (r *ExpireAsync) _marshalJSONRunID(x RunID) ([]byte, error) {
	result, err := shared.JSONMarshal[RunID](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: ExpireAsync._marshalJSONRunID:; %w", err)
	}
	return result, nil
}
func (r *ExpireAsync) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONExpireAsync(data)
	if err != nil {
		return fmt.Errorf("workflow: ExpireAsync.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *ExpireAsync) _unmarshalJSONExpireAsync(data []byte) (ExpireAsync, error) {
	result := ExpireAsync{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: ExpireAsync._unmarshalJSONExpireAsync: native struct unwrap; %w", err)
	}
	if fieldRunID, ok := partial["RunID"]; ok {
		result.RunID, err = r._unmarshalJSONRunID(fieldRunID)
		if err != nil {
			return result, fmt.Errorf("workflow: ExpireAsync._unmarshalJSONExpireAsync: field RunID; %w", err)
		}
	}
	return result, nil
}
func (r *ExpireAsync) _unmarshalJSONRunID(data []byte) (RunID, error) {
	result, err := shared.JSONUnmarshal[RunID](data)
	if err != nil {
		return result, fmt.Errorf("workflow: ExpireAsync._unmarshalJSONRunID: native ref unwrap; %w", err)
	}
	return result, nil
}

type ExprVisitor interface {
	VisitEnd(v *End) any
	VisitAssign(v *Assign) any
	VisitApply(v *Apply) any
	VisitChoose(v *Choose) any
}

type Expr interface {
	AcceptExpr(g ExprVisitor) any
}

var (
	_ Expr = (*End)(nil)
	_ Expr = (*Assign)(nil)
	_ Expr = (*Apply)(nil)
	_ Expr = (*Choose)(nil)
)

func (r *End) AcceptExpr(v ExprVisitor) any    { return v.VisitEnd(r) }
func (r *Assign) AcceptExpr(v ExprVisitor) any { return v.VisitAssign(r) }
func (r *Apply) AcceptExpr(v ExprVisitor) any  { return v.VisitApply(r) }
func (r *Choose) AcceptExpr(v ExprVisitor) any { return v.VisitChoose(r) }

func MatchExprR3[T0, T1, T2 any](
	x Expr,
	f1 func(x *End) (T0, T1, T2),
	f2 func(x *Assign) (T0, T1, T2),
	f3 func(x *Apply) (T0, T1, T2),
	f4 func(x *Choose) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *End:
		return f1(v)
	case *Assign:
		return f2(v)
	case *Apply:
		return f3(v)
	case *Choose:
		return f4(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchExprR2[T0, T1 any](
	x Expr,
	f1 func(x *End) (T0, T1),
	f2 func(x *Assign) (T0, T1),
	f3 func(x *Apply) (T0, T1),
	f4 func(x *Choose) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *End:
		return f1(v)
	case *Assign:
		return f2(v)
	case *Apply:
		return f3(v)
	case *Choose:
		return f4(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchExprR1[T0 any](
	x Expr,
	f1 func(x *End) T0,
	f2 func(x *Assign) T0,
	f3 func(x *Apply) T0,
	f4 func(x *Choose) T0,
) T0 {
	switch v := x.(type) {
	case *End:
		return f1(v)
	case *Assign:
		return f2(v)
	case *Apply:
		return f3(v)
	case *Choose:
		return f4(v)
	}
	var result1 T0
	return result1
}

func MatchExprR0(
	x Expr,
	f1 func(x *End),
	f2 func(x *Assign),
	f3 func(x *Apply),
	f4 func(x *Choose),
) {
	switch v := x.(type) {
	case *End:
		f1(v)
	case *Assign:
		f2(v)
	case *Apply:
		f3(v)
	case *Choose:
		f4(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Apply", ApplyFromJSON, ApplyToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Assign", AssignFromJSON, AssignToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Choose", ChooseFromJSON, ChooseToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.End", EndFromJSON, EndToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Expr", ExprFromJSON, ExprToJSON)
}

type ExprUnionJSON struct {
	Type   string          `json:"question_type,omitempty"`
	End    json.RawMessage `json:"workflow.End,omitempty"`
	Assign json.RawMessage `json:"workflow.Assign,omitempty"`
	Apply  json.RawMessage `json:"workflow.Apply,omitempty"`
	Choose json.RawMessage `json:"workflow.Choose,omitempty"`
}

func ExprFromJSON(x []byte) (Expr, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data ExprUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("workflow.ExprFromJSON: %w", err)
	}

	switch data.Type {
	case "workflow.End":
		return EndFromJSON(data.End)
	case "workflow.Assign":
		return AssignFromJSON(data.Assign)
	case "workflow.Apply":
		return ApplyFromJSON(data.Apply)
	case "workflow.Choose":
		return ChooseFromJSON(data.Choose)
	}

	if data.End != nil {
		return EndFromJSON(data.End)
	} else if data.Assign != nil {
		return AssignFromJSON(data.Assign)
	} else if data.Apply != nil {
		return ApplyFromJSON(data.Apply)
	} else if data.Choose != nil {
		return ChooseFromJSON(data.Choose)
	}
	return nil, fmt.Errorf("workflow.ExprFromJSON: unknown type: %s", data.Type)
}

func ExprToJSON(x Expr) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchExprR2(
		x,
		func(y *End) ([]byte, error) {
			body, err := EndToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.ExprToJSON: %w", err)
			}
			return json.Marshal(ExprUnionJSON{
				Type: "workflow.End",
				End:  body,
			})
		},
		func(y *Assign) ([]byte, error) {
			body, err := AssignToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.ExprToJSON: %w", err)
			}
			return json.Marshal(ExprUnionJSON{
				Type:   "workflow.Assign",
				Assign: body,
			})
		},
		func(y *Apply) ([]byte, error) {
			body, err := ApplyToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.ExprToJSON: %w", err)
			}
			return json.Marshal(ExprUnionJSON{
				Type:  "workflow.Apply",
				Apply: body,
			})
		},
		func(y *Choose) ([]byte, error) {
			body, err := ChooseToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.ExprToJSON: %w", err)
			}
			return json.Marshal(ExprUnionJSON{
				Type:   "workflow.Choose",
				Choose: body,
			})
		},
	)
}

func EndFromJSON(x []byte) (*End, error) {
	result := new(End)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.EndFromJSON: %w", err)
	}
	return result, nil
}

func EndToJSON(x *End) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*End)(nil)
	_ json.Marshaler   = (*End)(nil)
)

func (r *End) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONEnd(*r)
}
func (r *End) _marshalJSONEnd(x End) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldID []byte
	fieldID, err = r._marshalJSONStepID(x.ID)
	if err != nil {
		return nil, fmt.Errorf("workflow: End._marshalJSONEnd: field name ID; %w", err)
	}
	partial["ID"] = fieldID
	var fieldResult []byte
	fieldResult, err = r._marshalJSONReshaper(x.Result)
	if err != nil {
		return nil, fmt.Errorf("workflow: End._marshalJSONEnd: field name Result; %w", err)
	}
	partial["Result"] = fieldResult
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: End._marshalJSONEnd: struct; %w", err)
	}
	return result, nil
}
func (r *End) _marshalJSONStepID(x StepID) ([]byte, error) {
	result, err := shared.JSONMarshal[StepID](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: End._marshalJSONStepID:; %w", err)
	}
	return result, nil
}
func (r *End) _marshalJSONReshaper(x Reshaper) ([]byte, error) {
	result, err := shared.JSONMarshal[Reshaper](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: End._marshalJSONReshaper:; %w", err)
	}
	return result, nil
}
func (r *End) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONEnd(data)
	if err != nil {
		return fmt.Errorf("workflow: End.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *End) _unmarshalJSONEnd(data []byte) (End, error) {
	result := End{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: End._unmarshalJSONEnd: native struct unwrap; %w", err)
	}
	if fieldID, ok := partial["ID"]; ok {
		result.ID, err = r._unmarshalJSONStepID(fieldID)
		if err != nil {
			return result, fmt.Errorf("workflow: End._unmarshalJSONEnd: field ID; %w", err)
		}
	}
	if fieldResult, ok := partial["Result"]; ok {
		result.Result, err = r._unmarshalJSONReshaper(fieldResult)
		if err != nil {
			return result, fmt.Errorf("workflow: End._unmarshalJSONEnd: field Result; %w", err)
		}
	}
	return result, nil
}
func (r *End) _unmarshalJSONStepID(data []byte) (StepID, error) {
	result, err := shared.JSONUnmarshal[StepID](data)
	if err != nil {
		return result, fmt.Errorf("workflow: End._unmarshalJSONStepID: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *End) _unmarshalJSONReshaper(data []byte) (Reshaper, error) {
	result, err := shared.JSONUnmarshal[Reshaper](data)
	if err != nil {
		return result, fmt.Errorf("workflow: End._unmarshalJSONReshaper: native ref unwrap; %w", err)
	}
	return result, nil
}

func AssignFromJSON(x []byte) (*Assign, error) {
	result := new(Assign)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.AssignFromJSON: %w", err)
	}
	return result, nil
}

func AssignToJSON(x *Assign) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Assign)(nil)
	_ json.Marshaler   = (*Assign)(nil)
)

func (r *Assign) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAssign(*r)
}
func (r *Assign) _marshalJSONAssign(x Assign) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldID []byte
	fieldID, err = r._marshalJSONStepID(x.ID)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONAssign: field name ID; %w", err)
	}
	partial["ID"] = fieldID
	var fieldVarOk []byte
	fieldVarOk, err = r._marshalJSONstring(x.VarOk)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONAssign: field name VarOk; %w", err)
	}
	partial["VarOk"] = fieldVarOk
	var fieldVarErr []byte
	fieldVarErr, err = r._marshalJSONstring(x.VarErr)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONAssign: field name VarErr; %w", err)
	}
	partial["VarErr"] = fieldVarErr
	var fieldVal []byte
	fieldVal, err = r._marshalJSONExpr(x.Val)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONAssign: field name Val; %w", err)
	}
	partial["Val"] = fieldVal
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONAssign: struct; %w", err)
	}
	return result, nil
}
func (r *Assign) _marshalJSONStepID(x StepID) ([]byte, error) {
	result, err := shared.JSONMarshal[StepID](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONStepID:; %w", err)
	}
	return result, nil
}
func (r *Assign) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Assign) _marshalJSONExpr(x Expr) ([]byte, error) {
	result, err := shared.JSONMarshal[Expr](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONExpr:; %w", err)
	}
	return result, nil
}
func (r *Assign) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAssign(data)
	if err != nil {
		return fmt.Errorf("workflow: Assign.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Assign) _unmarshalJSONAssign(data []byte) (Assign, error) {
	result := Assign{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Assign._unmarshalJSONAssign: native struct unwrap; %w", err)
	}
	if fieldID, ok := partial["ID"]; ok {
		result.ID, err = r._unmarshalJSONStepID(fieldID)
		if err != nil {
			return result, fmt.Errorf("workflow: Assign._unmarshalJSONAssign: field ID; %w", err)
		}
	}
	if fieldVarOk, ok := partial["VarOk"]; ok {
		result.VarOk, err = r._unmarshalJSONstring(fieldVarOk)
		if err != nil {
			return result, fmt.Errorf("workflow: Assign._unmarshalJSONAssign: field VarOk; %w", err)
		}
	}
	if fieldVarErr, ok := partial["VarErr"]; ok {
		result.VarErr, err = r._unmarshalJSONstring(fieldVarErr)
		if err != nil {
			return result, fmt.Errorf("workflow: Assign._unmarshalJSONAssign: field VarErr; %w", err)
		}
	}
	if fieldVal, ok := partial["Val"]; ok {
		result.Val, err = r._unmarshalJSONExpr(fieldVal)
		if err != nil {
			return result, fmt.Errorf("workflow: Assign._unmarshalJSONAssign: field Val; %w", err)
		}
	}
	return result, nil
}
func (r *Assign) _unmarshalJSONStepID(data []byte) (StepID, error) {
	result, err := shared.JSONUnmarshal[StepID](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Assign._unmarshalJSONStepID: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *Assign) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Assign._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *Assign) _unmarshalJSONExpr(data []byte) (Expr, error) {
	result, err := shared.JSONUnmarshal[Expr](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Assign._unmarshalJSONExpr: native ref unwrap; %w", err)
	}
	return result, nil
}

func ApplyFromJSON(x []byte) (*Apply, error) {
	result := new(Apply)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.ApplyFromJSON: %w", err)
	}
	return result, nil
}

func ApplyToJSON(x *Apply) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Apply)(nil)
	_ json.Marshaler   = (*Apply)(nil)
)

func (r *Apply) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONApply(*r)
}
func (r *Apply) _marshalJSONApply(x Apply) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldID []byte
	fieldID, err = r._marshalJSONStepID(x.ID)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONApply: field name ID; %w", err)
	}
	partial["ID"] = fieldID
	var fieldName []byte
	fieldName, err = r._marshalJSONstring(x.Name)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONApply: field name Name; %w", err)
	}
	partial["Name"] = fieldName
	var fieldArgs []byte
	fieldArgs, err = r._marshalJSONSliceReshaper(x.Args)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONApply: field name Args; %w", err)
	}
	partial["Args"] = fieldArgs
	var fieldAwait []byte
	fieldAwait, err = r._marshalJSONPtrApplyAwaitOptions(x.Await)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONApply: field name Await; %w", err)
	}
	if fieldAwait != nil {
		partial["Await"] = fieldAwait
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONApply: struct; %w", err)
	}
	return result, nil
}
func (r *Apply) _marshalJSONStepID(x StepID) ([]byte, error) {
	result, err := shared.JSONMarshal[StepID](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONStepID:; %w", err)
	}
	return result, nil
}
func (r *Apply) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Apply) _marshalJSONSliceReshaper(x []Reshaper) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONReshaper(v)
		if err != nil {
			return nil, fmt.Errorf("workflow: Apply._marshalJSONSliceReshaper: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONSliceReshaper:; %w", err)
	}
	return result, nil
}
func (r *Apply) _marshalJSONReshaper(x Reshaper) ([]byte, error) {
	result, err := shared.JSONMarshal[Reshaper](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONReshaper:; %w", err)
	}
	return result, nil
}
func (r *Apply) _marshalJSONPtrApplyAwaitOptions(x *ApplyAwaitOptions) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return r._marshalJSONApplyAwaitOptions(*x)
}
func (r *Apply) _marshalJSONApplyAwaitOptions(x ApplyAwaitOptions) ([]byte, error) {
	result, err := shared.JSONMarshal[ApplyAwaitOptions](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONApplyAwaitOptions:; %w", err)
	}
	return result, nil
}
func (r *Apply) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONApply(data)
	if err != nil {
		return fmt.Errorf("workflow: Apply.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Apply) _unmarshalJSONApply(data []byte) (Apply, error) {
	result := Apply{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Apply._unmarshalJSONApply: native struct unwrap; %w", err)
	}
	if fieldID, ok := partial["ID"]; ok {
		result.ID, err = r._unmarshalJSONStepID(fieldID)
		if err != nil {
			return result, fmt.Errorf("workflow: Apply._unmarshalJSONApply: field ID; %w", err)
		}
	}
	if fieldName, ok := partial["Name"]; ok {
		result.Name, err = r._unmarshalJSONstring(fieldName)
		if err != nil {
			return result, fmt.Errorf("workflow: Apply._unmarshalJSONApply: field Name; %w", err)
		}
	}
	if fieldArgs, ok := partial["Args"]; ok {
		result.Args, err = r._unmarshalJSONSliceReshaper(fieldArgs)
		if err != nil {
			return result, fmt.Errorf("workflow: Apply._unmarshalJSONApply: field Args; %w", err)
		}
	}
	if fieldAwait, ok := partial["Await"]; ok {
		result.Await, err = r._unmarshalJSONPtrApplyAwaitOptions(fieldAwait)
		if err != nil {
			return result, fmt.Errorf("workflow: Apply._unmarshalJSONApply: field Await; %w", err)
		}
	}
	return result, nil
}
func (r *Apply) _unmarshalJSONStepID(data []byte) (StepID, error) {
	result, err := shared.JSONUnmarshal[StepID](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Apply._unmarshalJSONStepID: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *Apply) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Apply._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *Apply) _unmarshalJSONSliceReshaper(data []byte) ([]Reshaper, error) {
	result := make([]Reshaper, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Apply._unmarshalJSONSliceReshaper: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONReshaper(v)
		if err != nil {
			return result, fmt.Errorf("workflow: Apply._unmarshalJSONSliceReshaper: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *Apply) _unmarshalJSONReshaper(data []byte) (Reshaper, error) {
	result, err := shared.JSONUnmarshal[Reshaper](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Apply._unmarshalJSONReshaper: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *Apply) _unmarshalJSONPtrApplyAwaitOptions(data []byte) (*ApplyAwaitOptions, error) {
	if len(data) == 0 {
		return nil, nil
	}
	if string(data[:4]) == "null" {
		return nil, nil
	}
	result, err := r._unmarshalJSONApplyAwaitOptions(data)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._unmarshalJSONPtrApplyAwaitOptions: pointer; %w", err)
	}
	return &result, nil
}
func (r *Apply) _unmarshalJSONApplyAwaitOptions(data []byte) (ApplyAwaitOptions, error) {
	result, err := shared.JSONUnmarshal[ApplyAwaitOptions](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Apply._unmarshalJSONApplyAwaitOptions: native ref unwrap; %w", err)
	}
	return result, nil
}

func ChooseFromJSON(x []byte) (*Choose, error) {
	result := new(Choose)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.ChooseFromJSON: %w", err)
	}
	return result, nil
}

func ChooseToJSON(x *Choose) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Choose)(nil)
	_ json.Marshaler   = (*Choose)(nil)
)

func (r *Choose) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONChoose(*r)
}
func (r *Choose) _marshalJSONChoose(x Choose) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldID []byte
	fieldID, err = r._marshalJSONStepID(x.ID)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONChoose: field name ID; %w", err)
	}
	partial["ID"] = fieldID
	var fieldIf []byte
	fieldIf, err = r._marshalJSONPredicate(x.If)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONChoose: field name If; %w", err)
	}
	partial["If"] = fieldIf
	var fieldThen []byte
	fieldThen, err = r._marshalJSONSliceExpr(x.Then)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONChoose: field name Then; %w", err)
	}
	partial["Then"] = fieldThen
	var fieldElse []byte
	fieldElse, err = r._marshalJSONSliceExpr(x.Else)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONChoose: field name Else; %w", err)
	}
	partial["Else"] = fieldElse
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONChoose: struct; %w", err)
	}
	return result, nil
}
func (r *Choose) _marshalJSONStepID(x StepID) ([]byte, error) {
	result, err := shared.JSONMarshal[StepID](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONStepID:; %w", err)
	}
	return result, nil
}
func (r *Choose) _marshalJSONPredicate(x Predicate) ([]byte, error) {
	result, err := shared.JSONMarshal[Predicate](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONPredicate:; %w", err)
	}
	return result, nil
}
func (r *Choose) _marshalJSONSliceExpr(x []Expr) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONExpr(v)
		if err != nil {
			return nil, fmt.Errorf("workflow: Choose._marshalJSONSliceExpr: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONSliceExpr:; %w", err)
	}
	return result, nil
}
func (r *Choose) _marshalJSONExpr(x Expr) ([]byte, error) {
	result, err := shared.JSONMarshal[Expr](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONExpr:; %w", err)
	}
	return result, nil
}
func (r *Choose) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONChoose(data)
	if err != nil {
		return fmt.Errorf("workflow: Choose.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Choose) _unmarshalJSONChoose(data []byte) (Choose, error) {
	result := Choose{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Choose._unmarshalJSONChoose: native struct unwrap; %w", err)
	}
	if fieldID, ok := partial["ID"]; ok {
		result.ID, err = r._unmarshalJSONStepID(fieldID)
		if err != nil {
			return result, fmt.Errorf("workflow: Choose._unmarshalJSONChoose: field ID; %w", err)
		}
	}
	if fieldIf, ok := partial["If"]; ok {
		result.If, err = r._unmarshalJSONPredicate(fieldIf)
		if err != nil {
			return result, fmt.Errorf("workflow: Choose._unmarshalJSONChoose: field If; %w", err)
		}
	}
	if fieldThen, ok := partial["Then"]; ok {
		result.Then, err = r._unmarshalJSONSliceExpr(fieldThen)
		if err != nil {
			return result, fmt.Errorf("workflow: Choose._unmarshalJSONChoose: field Then; %w", err)
		}
	}
	if fieldElse, ok := partial["Else"]; ok {
		result.Else, err = r._unmarshalJSONSliceExpr(fieldElse)
		if err != nil {
			return result, fmt.Errorf("workflow: Choose._unmarshalJSONChoose: field Else; %w", err)
		}
	}
	return result, nil
}
func (r *Choose) _unmarshalJSONStepID(data []byte) (StepID, error) {
	result, err := shared.JSONUnmarshal[StepID](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Choose._unmarshalJSONStepID: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *Choose) _unmarshalJSONPredicate(data []byte) (Predicate, error) {
	result, err := shared.JSONUnmarshal[Predicate](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Choose._unmarshalJSONPredicate: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *Choose) _unmarshalJSONSliceExpr(data []byte) ([]Expr, error) {
	result := make([]Expr, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Choose._unmarshalJSONSliceExpr: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONExpr(v)
		if err != nil {
			return result, fmt.Errorf("workflow: Choose._unmarshalJSONSliceExpr: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *Choose) _unmarshalJSONExpr(data []byte) (Expr, error) {
	result, err := shared.JSONUnmarshal[Expr](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Choose._unmarshalJSONExpr: native ref unwrap; %w", err)
	}
	return result, nil
}

type PredicateVisitor interface {
	VisitAnd(v *And) any
	VisitOr(v *Or) any
	VisitNot(v *Not) any
	VisitCompare(v *Compare) any
}

type Predicate interface {
	AcceptPredicate(g PredicateVisitor) any
}

var (
	_ Predicate = (*And)(nil)
	_ Predicate = (*Or)(nil)
	_ Predicate = (*Not)(nil)
	_ Predicate = (*Compare)(nil)
)

func (r *And) AcceptPredicate(v PredicateVisitor) any     { return v.VisitAnd(r) }
func (r *Or) AcceptPredicate(v PredicateVisitor) any      { return v.VisitOr(r) }
func (r *Not) AcceptPredicate(v PredicateVisitor) any     { return v.VisitNot(r) }
func (r *Compare) AcceptPredicate(v PredicateVisitor) any { return v.VisitCompare(r) }

func MatchPredicateR3[T0, T1, T2 any](
	x Predicate,
	f1 func(x *And) (T0, T1, T2),
	f2 func(x *Or) (T0, T1, T2),
	f3 func(x *Not) (T0, T1, T2),
	f4 func(x *Compare) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *And:
		return f1(v)
	case *Or:
		return f2(v)
	case *Not:
		return f3(v)
	case *Compare:
		return f4(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchPredicateR2[T0, T1 any](
	x Predicate,
	f1 func(x *And) (T0, T1),
	f2 func(x *Or) (T0, T1),
	f3 func(x *Not) (T0, T1),
	f4 func(x *Compare) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *And:
		return f1(v)
	case *Or:
		return f2(v)
	case *Not:
		return f3(v)
	case *Compare:
		return f4(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchPredicateR1[T0 any](
	x Predicate,
	f1 func(x *And) T0,
	f2 func(x *Or) T0,
	f3 func(x *Not) T0,
	f4 func(x *Compare) T0,
) T0 {
	switch v := x.(type) {
	case *And:
		return f1(v)
	case *Or:
		return f2(v)
	case *Not:
		return f3(v)
	case *Compare:
		return f4(v)
	}
	var result1 T0
	return result1
}

func MatchPredicateR0(
	x Predicate,
	f1 func(x *And),
	f2 func(x *Or),
	f3 func(x *Not),
	f4 func(x *Compare),
) {
	switch v := x.(type) {
	case *And:
		f1(v)
	case *Or:
		f2(v)
	case *Not:
		f3(v)
	case *Compare:
		f4(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.And", AndFromJSON, AndToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Compare", CompareFromJSON, CompareToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Not", NotFromJSON, NotToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Or", OrFromJSON, OrToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Predicate", PredicateFromJSON, PredicateToJSON)
}

type PredicateUnionJSON struct {
	Type    string          `json:"question_type,omitempty"`
	And     json.RawMessage `json:"workflow.And,omitempty"`
	Or      json.RawMessage `json:"workflow.Or,omitempty"`
	Not     json.RawMessage `json:"workflow.Not,omitempty"`
	Compare json.RawMessage `json:"workflow.Compare,omitempty"`
}

func PredicateFromJSON(x []byte) (Predicate, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data PredicateUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("workflow.PredicateFromJSON: %w", err)
	}

	switch data.Type {
	case "workflow.And":
		return AndFromJSON(data.And)
	case "workflow.Or":
		return OrFromJSON(data.Or)
	case "workflow.Not":
		return NotFromJSON(data.Not)
	case "workflow.Compare":
		return CompareFromJSON(data.Compare)
	}

	if data.And != nil {
		return AndFromJSON(data.And)
	} else if data.Or != nil {
		return OrFromJSON(data.Or)
	} else if data.Not != nil {
		return NotFromJSON(data.Not)
	} else if data.Compare != nil {
		return CompareFromJSON(data.Compare)
	}
	return nil, fmt.Errorf("workflow.PredicateFromJSON: unknown type: %s", data.Type)
}

func PredicateToJSON(x Predicate) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchPredicateR2(
		x,
		func(y *And) ([]byte, error) {
			body, err := AndToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.PredicateToJSON: %w", err)
			}
			return json.Marshal(PredicateUnionJSON{
				Type: "workflow.And",
				And:  body,
			})
		},
		func(y *Or) ([]byte, error) {
			body, err := OrToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.PredicateToJSON: %w", err)
			}
			return json.Marshal(PredicateUnionJSON{
				Type: "workflow.Or",
				Or:   body,
			})
		},
		func(y *Not) ([]byte, error) {
			body, err := NotToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.PredicateToJSON: %w", err)
			}
			return json.Marshal(PredicateUnionJSON{
				Type: "workflow.Not",
				Not:  body,
			})
		},
		func(y *Compare) ([]byte, error) {
			body, err := CompareToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.PredicateToJSON: %w", err)
			}
			return json.Marshal(PredicateUnionJSON{
				Type:    "workflow.Compare",
				Compare: body,
			})
		},
	)
}

func AndFromJSON(x []byte) (*And, error) {
	result := new(And)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.AndFromJSON: %w", err)
	}
	return result, nil
}

func AndToJSON(x *And) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*And)(nil)
	_ json.Marshaler   = (*And)(nil)
)

func (r *And) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAnd(*r)
}
func (r *And) _marshalJSONAnd(x And) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldL []byte
	fieldL, err = r._marshalJSONSlicePredicate(x.L)
	if err != nil {
		return nil, fmt.Errorf("workflow: And._marshalJSONAnd: field name L; %w", err)
	}
	partial["L"] = fieldL
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: And._marshalJSONAnd: struct; %w", err)
	}
	return result, nil
}
func (r *And) _marshalJSONSlicePredicate(x []Predicate) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONPredicate(v)
		if err != nil {
			return nil, fmt.Errorf("workflow: And._marshalJSONSlicePredicate: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: And._marshalJSONSlicePredicate:; %w", err)
	}
	return result, nil
}
func (r *And) _marshalJSONPredicate(x Predicate) ([]byte, error) {
	result, err := shared.JSONMarshal[Predicate](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: And._marshalJSONPredicate:; %w", err)
	}
	return result, nil
}
func (r *And) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAnd(data)
	if err != nil {
		return fmt.Errorf("workflow: And.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *And) _unmarshalJSONAnd(data []byte) (And, error) {
	result := And{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: And._unmarshalJSONAnd: native struct unwrap; %w", err)
	}
	if fieldL, ok := partial["L"]; ok {
		result.L, err = r._unmarshalJSONSlicePredicate(fieldL)
		if err != nil {
			return result, fmt.Errorf("workflow: And._unmarshalJSONAnd: field L; %w", err)
		}
	}
	return result, nil
}
func (r *And) _unmarshalJSONSlicePredicate(data []byte) ([]Predicate, error) {
	result := make([]Predicate, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: And._unmarshalJSONSlicePredicate: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONPredicate(v)
		if err != nil {
			return result, fmt.Errorf("workflow: And._unmarshalJSONSlicePredicate: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *And) _unmarshalJSONPredicate(data []byte) (Predicate, error) {
	result, err := shared.JSONUnmarshal[Predicate](data)
	if err != nil {
		return result, fmt.Errorf("workflow: And._unmarshalJSONPredicate: native ref unwrap; %w", err)
	}
	return result, nil
}

func OrFromJSON(x []byte) (*Or, error) {
	result := new(Or)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.OrFromJSON: %w", err)
	}
	return result, nil
}

func OrToJSON(x *Or) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Or)(nil)
	_ json.Marshaler   = (*Or)(nil)
)

func (r *Or) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONOr(*r)
}
func (r *Or) _marshalJSONOr(x Or) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldL []byte
	fieldL, err = r._marshalJSONSlicePredicate(x.L)
	if err != nil {
		return nil, fmt.Errorf("workflow: Or._marshalJSONOr: field name L; %w", err)
	}
	partial["L"] = fieldL
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Or._marshalJSONOr: struct; %w", err)
	}
	return result, nil
}
func (r *Or) _marshalJSONSlicePredicate(x []Predicate) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONPredicate(v)
		if err != nil {
			return nil, fmt.Errorf("workflow: Or._marshalJSONSlicePredicate: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Or._marshalJSONSlicePredicate:; %w", err)
	}
	return result, nil
}
func (r *Or) _marshalJSONPredicate(x Predicate) ([]byte, error) {
	result, err := shared.JSONMarshal[Predicate](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Or._marshalJSONPredicate:; %w", err)
	}
	return result, nil
}
func (r *Or) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONOr(data)
	if err != nil {
		return fmt.Errorf("workflow: Or.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Or) _unmarshalJSONOr(data []byte) (Or, error) {
	result := Or{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Or._unmarshalJSONOr: native struct unwrap; %w", err)
	}
	if fieldL, ok := partial["L"]; ok {
		result.L, err = r._unmarshalJSONSlicePredicate(fieldL)
		if err != nil {
			return result, fmt.Errorf("workflow: Or._unmarshalJSONOr: field L; %w", err)
		}
	}
	return result, nil
}
func (r *Or) _unmarshalJSONSlicePredicate(data []byte) ([]Predicate, error) {
	result := make([]Predicate, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Or._unmarshalJSONSlicePredicate: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONPredicate(v)
		if err != nil {
			return result, fmt.Errorf("workflow: Or._unmarshalJSONSlicePredicate: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *Or) _unmarshalJSONPredicate(data []byte) (Predicate, error) {
	result, err := shared.JSONUnmarshal[Predicate](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Or._unmarshalJSONPredicate: native ref unwrap; %w", err)
	}
	return result, nil
}

func NotFromJSON(x []byte) (*Not, error) {
	result := new(Not)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.NotFromJSON: %w", err)
	}
	return result, nil
}

func NotToJSON(x *Not) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Not)(nil)
	_ json.Marshaler   = (*Not)(nil)
)

func (r *Not) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONNot(*r)
}
func (r *Not) _marshalJSONNot(x Not) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldP []byte
	fieldP, err = r._marshalJSONPredicate(x.P)
	if err != nil {
		return nil, fmt.Errorf("workflow: Not._marshalJSONNot: field name P; %w", err)
	}
	partial["P"] = fieldP
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Not._marshalJSONNot: struct; %w", err)
	}
	return result, nil
}
func (r *Not) _marshalJSONPredicate(x Predicate) ([]byte, error) {
	result, err := shared.JSONMarshal[Predicate](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Not._marshalJSONPredicate:; %w", err)
	}
	return result, nil
}
func (r *Not) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONNot(data)
	if err != nil {
		return fmt.Errorf("workflow: Not.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Not) _unmarshalJSONNot(data []byte) (Not, error) {
	result := Not{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Not._unmarshalJSONNot: native struct unwrap; %w", err)
	}
	if fieldP, ok := partial["P"]; ok {
		result.P, err = r._unmarshalJSONPredicate(fieldP)
		if err != nil {
			return result, fmt.Errorf("workflow: Not._unmarshalJSONNot: field P; %w", err)
		}
	}
	return result, nil
}
func (r *Not) _unmarshalJSONPredicate(data []byte) (Predicate, error) {
	result, err := shared.JSONUnmarshal[Predicate](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Not._unmarshalJSONPredicate: native ref unwrap; %w", err)
	}
	return result, nil
}

func CompareFromJSON(x []byte) (*Compare, error) {
	result := new(Compare)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.CompareFromJSON: %w", err)
	}
	return result, nil
}

func CompareToJSON(x *Compare) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Compare)(nil)
	_ json.Marshaler   = (*Compare)(nil)
)

func (r *Compare) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONCompare(*r)
}
func (r *Compare) _marshalJSONCompare(x Compare) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldOperation []byte
	fieldOperation, err = r._marshalJSONstring(x.Operation)
	if err != nil {
		return nil, fmt.Errorf("workflow: Compare._marshalJSONCompare: field name Operation; %w", err)
	}
	partial["Operation"] = fieldOperation
	var fieldLeft []byte
	fieldLeft, err = r._marshalJSONReshaper(x.Left)
	if err != nil {
		return nil, fmt.Errorf("workflow: Compare._marshalJSONCompare: field name Left; %w", err)
	}
	partial["Left"] = fieldLeft
	var fieldRight []byte
	fieldRight, err = r._marshalJSONReshaper(x.Right)
	if err != nil {
		return nil, fmt.Errorf("workflow: Compare._marshalJSONCompare: field name Right; %w", err)
	}
	partial["Right"] = fieldRight
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Compare._marshalJSONCompare: struct; %w", err)
	}
	return result, nil
}
func (r *Compare) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Compare._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Compare) _marshalJSONReshaper(x Reshaper) ([]byte, error) {
	result, err := shared.JSONMarshal[Reshaper](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Compare._marshalJSONReshaper:; %w", err)
	}
	return result, nil
}
func (r *Compare) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONCompare(data)
	if err != nil {
		return fmt.Errorf("workflow: Compare.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Compare) _unmarshalJSONCompare(data []byte) (Compare, error) {
	result := Compare{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Compare._unmarshalJSONCompare: native struct unwrap; %w", err)
	}
	if fieldOperation, ok := partial["Operation"]; ok {
		result.Operation, err = r._unmarshalJSONstring(fieldOperation)
		if err != nil {
			return result, fmt.Errorf("workflow: Compare._unmarshalJSONCompare: field Operation; %w", err)
		}
	}
	if fieldLeft, ok := partial["Left"]; ok {
		result.Left, err = r._unmarshalJSONReshaper(fieldLeft)
		if err != nil {
			return result, fmt.Errorf("workflow: Compare._unmarshalJSONCompare: field Left; %w", err)
		}
	}
	if fieldRight, ok := partial["Right"]; ok {
		result.Right, err = r._unmarshalJSONReshaper(fieldRight)
		if err != nil {
			return result, fmt.Errorf("workflow: Compare._unmarshalJSONCompare: field Right; %w", err)
		}
	}
	return result, nil
}
func (r *Compare) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Compare._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *Compare) _unmarshalJSONReshaper(data []byte) (Reshaper, error) {
	result, err := shared.JSONUnmarshal[Reshaper](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Compare._unmarshalJSONReshaper: native ref unwrap; %w", err)
	}
	return result, nil
}

type ReshaperVisitor interface {
	VisitGetValue(v *GetValue) any
	VisitSetValue(v *SetValue) any
}

type Reshaper interface {
	AcceptReshaper(g ReshaperVisitor) any
}

var (
	_ Reshaper = (*GetValue)(nil)
	_ Reshaper = (*SetValue)(nil)
)

func (r *GetValue) AcceptReshaper(v ReshaperVisitor) any { return v.VisitGetValue(r) }
func (r *SetValue) AcceptReshaper(v ReshaperVisitor) any { return v.VisitSetValue(r) }

func MatchReshaperR3[T0, T1, T2 any](
	x Reshaper,
	f1 func(x *GetValue) (T0, T1, T2),
	f2 func(x *SetValue) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *GetValue:
		return f1(v)
	case *SetValue:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchReshaperR2[T0, T1 any](
	x Reshaper,
	f1 func(x *GetValue) (T0, T1),
	f2 func(x *SetValue) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *GetValue:
		return f1(v)
	case *SetValue:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchReshaperR1[T0 any](
	x Reshaper,
	f1 func(x *GetValue) T0,
	f2 func(x *SetValue) T0,
) T0 {
	switch v := x.(type) {
	case *GetValue:
		return f1(v)
	case *SetValue:
		return f2(v)
	}
	var result1 T0
	return result1
}

func MatchReshaperR0(
	x Reshaper,
	f1 func(x *GetValue),
	f2 func(x *SetValue),
) {
	switch v := x.(type) {
	case *GetValue:
		f1(v)
	case *SetValue:
		f2(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.GetValue", GetValueFromJSON, GetValueToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Reshaper", ReshaperFromJSON, ReshaperToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.SetValue", SetValueFromJSON, SetValueToJSON)
}

type ReshaperUnionJSON struct {
	Type     string          `json:"question_type,omitempty"`
	GetValue json.RawMessage `json:"workflow.GetValue,omitempty"`
	SetValue json.RawMessage `json:"workflow.SetValue,omitempty"`
}

func ReshaperFromJSON(x []byte) (Reshaper, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data ReshaperUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("workflow.ReshaperFromJSON: %w", err)
	}

	switch data.Type {
	case "workflow.GetValue":
		return GetValueFromJSON(data.GetValue)
	case "workflow.SetValue":
		return SetValueFromJSON(data.SetValue)
	}

	if data.GetValue != nil {
		return GetValueFromJSON(data.GetValue)
	} else if data.SetValue != nil {
		return SetValueFromJSON(data.SetValue)
	}
	return nil, fmt.Errorf("workflow.ReshaperFromJSON: unknown type: %s", data.Type)
}

func ReshaperToJSON(x Reshaper) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchReshaperR2(
		x,
		func(y *GetValue) ([]byte, error) {
			body, err := GetValueToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.ReshaperToJSON: %w", err)
			}
			return json.Marshal(ReshaperUnionJSON{
				Type:     "workflow.GetValue",
				GetValue: body,
			})
		},
		func(y *SetValue) ([]byte, error) {
			body, err := SetValueToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.ReshaperToJSON: %w", err)
			}
			return json.Marshal(ReshaperUnionJSON{
				Type:     "workflow.SetValue",
				SetValue: body,
			})
		},
	)
}

func GetValueFromJSON(x []byte) (*GetValue, error) {
	result := new(GetValue)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.GetValueFromJSON: %w", err)
	}
	return result, nil
}

func GetValueToJSON(x *GetValue) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*GetValue)(nil)
	_ json.Marshaler   = (*GetValue)(nil)
)

func (r *GetValue) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONGetValue(*r)
}
func (r *GetValue) _marshalJSONGetValue(x GetValue) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldPath []byte
	fieldPath, err = r._marshalJSONstring(x.Path)
	if err != nil {
		return nil, fmt.Errorf("workflow: GetValue._marshalJSONGetValue: field name Path; %w", err)
	}
	partial["Path"] = fieldPath
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: GetValue._marshalJSONGetValue: struct; %w", err)
	}
	return result, nil
}
func (r *GetValue) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: GetValue._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *GetValue) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONGetValue(data)
	if err != nil {
		return fmt.Errorf("workflow: GetValue.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *GetValue) _unmarshalJSONGetValue(data []byte) (GetValue, error) {
	result := GetValue{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: GetValue._unmarshalJSONGetValue: native struct unwrap; %w", err)
	}
	if fieldPath, ok := partial["Path"]; ok {
		result.Path, err = r._unmarshalJSONstring(fieldPath)
		if err != nil {
			return result, fmt.Errorf("workflow: GetValue._unmarshalJSONGetValue: field Path; %w", err)
		}
	}
	return result, nil
}
func (r *GetValue) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: GetValue._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}

func SetValueFromJSON(x []byte) (*SetValue, error) {
	result := new(SetValue)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.SetValueFromJSON: %w", err)
	}
	return result, nil
}

func SetValueToJSON(x *SetValue) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*SetValue)(nil)
	_ json.Marshaler   = (*SetValue)(nil)
)

func (r *SetValue) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONSetValue(*r)
}
func (r *SetValue) _marshalJSONSetValue(x SetValue) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldValue []byte
	fieldValue, err = r._marshalJSONschema_Schema(x.Value)
	if err != nil {
		return nil, fmt.Errorf("workflow: SetValue._marshalJSONSetValue: field name Value; %w", err)
	}
	partial["Value"] = fieldValue
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: SetValue._marshalJSONSetValue: struct; %w", err)
	}
	return result, nil
}
func (r *SetValue) _marshalJSONschema_Schema(x schema.Schema) ([]byte, error) {
	result, err := shared.JSONMarshal[schema.Schema](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: SetValue._marshalJSONschema_Schema:; %w", err)
	}
	return result, nil
}
func (r *SetValue) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONSetValue(data)
	if err != nil {
		return fmt.Errorf("workflow: SetValue.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *SetValue) _unmarshalJSONSetValue(data []byte) (SetValue, error) {
	result := SetValue{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: SetValue._unmarshalJSONSetValue: native struct unwrap; %w", err)
	}
	if fieldValue, ok := partial["Value"]; ok {
		result.Value, err = r._unmarshalJSONschema_Schema(fieldValue)
		if err != nil {
			return result, fmt.Errorf("workflow: SetValue._unmarshalJSONSetValue: field Value; %w", err)
		}
	}
	return result, nil
}
func (r *SetValue) _unmarshalJSONschema_Schema(data []byte) (schema.Schema, error) {
	result, err := shared.JSONUnmarshal[schema.Schema](data)
	if err != nil {
		return result, fmt.Errorf("workflow: SetValue._unmarshalJSONschema_Schema: native ref unwrap; %w", err)
	}
	return result, nil
}

type RunOptionVisitor interface {
	VisitScheduleRun(v *ScheduleRun) any
	VisitDelayRun(v *DelayRun) any
}

type RunOption interface {
	AcceptRunOption(g RunOptionVisitor) any
}

var (
	_ RunOption = (*ScheduleRun)(nil)
	_ RunOption = (*DelayRun)(nil)
)

func (r *ScheduleRun) AcceptRunOption(v RunOptionVisitor) any { return v.VisitScheduleRun(r) }
func (r *DelayRun) AcceptRunOption(v RunOptionVisitor) any    { return v.VisitDelayRun(r) }

func MatchRunOptionR3[T0, T1, T2 any](
	x RunOption,
	f1 func(x *ScheduleRun) (T0, T1, T2),
	f2 func(x *DelayRun) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *ScheduleRun:
		return f1(v)
	case *DelayRun:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchRunOptionR2[T0, T1 any](
	x RunOption,
	f1 func(x *ScheduleRun) (T0, T1),
	f2 func(x *DelayRun) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *ScheduleRun:
		return f1(v)
	case *DelayRun:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchRunOptionR1[T0 any](
	x RunOption,
	f1 func(x *ScheduleRun) T0,
	f2 func(x *DelayRun) T0,
) T0 {
	switch v := x.(type) {
	case *ScheduleRun:
		return f1(v)
	case *DelayRun:
		return f2(v)
	}
	var result1 T0
	return result1
}

func MatchRunOptionR0(
	x RunOption,
	f1 func(x *ScheduleRun),
	f2 func(x *DelayRun),
) {
	switch v := x.(type) {
	case *ScheduleRun:
		f1(v)
	case *DelayRun:
		f2(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.DelayRun", DelayRunFromJSON, DelayRunToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.RunOption", RunOptionFromJSON, RunOptionToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.ScheduleRun", ScheduleRunFromJSON, ScheduleRunToJSON)
}

type RunOptionUnionJSON struct {
	Type        string          `json:"question_type,omitempty"`
	ScheduleRun json.RawMessage `json:"workflow.ScheduleRun,omitempty"`
	DelayRun    json.RawMessage `json:"workflow.DelayRun,omitempty"`
}

func RunOptionFromJSON(x []byte) (RunOption, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data RunOptionUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("workflow.RunOptionFromJSON: %w", err)
	}

	switch data.Type {
	case "workflow.ScheduleRun":
		return ScheduleRunFromJSON(data.ScheduleRun)
	case "workflow.DelayRun":
		return DelayRunFromJSON(data.DelayRun)
	}

	if data.ScheduleRun != nil {
		return ScheduleRunFromJSON(data.ScheduleRun)
	} else if data.DelayRun != nil {
		return DelayRunFromJSON(data.DelayRun)
	}
	return nil, fmt.Errorf("workflow.RunOptionFromJSON: unknown type: %s", data.Type)
}

func RunOptionToJSON(x RunOption) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchRunOptionR2(
		x,
		func(y *ScheduleRun) ([]byte, error) {
			body, err := ScheduleRunToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.RunOptionToJSON: %w", err)
			}
			return json.Marshal(RunOptionUnionJSON{
				Type:        "workflow.ScheduleRun",
				ScheduleRun: body,
			})
		},
		func(y *DelayRun) ([]byte, error) {
			body, err := DelayRunToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.RunOptionToJSON: %w", err)
			}
			return json.Marshal(RunOptionUnionJSON{
				Type:     "workflow.DelayRun",
				DelayRun: body,
			})
		},
	)
}

func ScheduleRunFromJSON(x []byte) (*ScheduleRun, error) {
	result := new(ScheduleRun)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.ScheduleRunFromJSON: %w", err)
	}
	return result, nil
}

func ScheduleRunToJSON(x *ScheduleRun) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*ScheduleRun)(nil)
	_ json.Marshaler   = (*ScheduleRun)(nil)
)

func (r *ScheduleRun) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONScheduleRun(*r)
}
func (r *ScheduleRun) _marshalJSONScheduleRun(x ScheduleRun) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldInterval []byte
	fieldInterval, err = r._marshalJSONstring(x.Interval)
	if err != nil {
		return nil, fmt.Errorf("workflow: ScheduleRun._marshalJSONScheduleRun: field name Interval; %w", err)
	}
	partial["Interval"] = fieldInterval
	var fieldParentRunID []byte
	fieldParentRunID, err = r._marshalJSONstring(x.ParentRunID)
	if err != nil {
		return nil, fmt.Errorf("workflow: ScheduleRun._marshalJSONScheduleRun: field name ParentRunID; %w", err)
	}
	partial["ParentRunID"] = fieldParentRunID
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: ScheduleRun._marshalJSONScheduleRun: struct; %w", err)
	}
	return result, nil
}
func (r *ScheduleRun) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: ScheduleRun._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *ScheduleRun) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONScheduleRun(data)
	if err != nil {
		return fmt.Errorf("workflow: ScheduleRun.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *ScheduleRun) _unmarshalJSONScheduleRun(data []byte) (ScheduleRun, error) {
	result := ScheduleRun{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: ScheduleRun._unmarshalJSONScheduleRun: native struct unwrap; %w", err)
	}
	if fieldInterval, ok := partial["Interval"]; ok {
		result.Interval, err = r._unmarshalJSONstring(fieldInterval)
		if err != nil {
			return result, fmt.Errorf("workflow: ScheduleRun._unmarshalJSONScheduleRun: field Interval; %w", err)
		}
	}
	if fieldParentRunID, ok := partial["ParentRunID"]; ok {
		result.ParentRunID, err = r._unmarshalJSONstring(fieldParentRunID)
		if err != nil {
			return result, fmt.Errorf("workflow: ScheduleRun._unmarshalJSONScheduleRun: field ParentRunID; %w", err)
		}
	}
	return result, nil
}
func (r *ScheduleRun) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: ScheduleRun._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}

func DelayRunFromJSON(x []byte) (*DelayRun, error) {
	result := new(DelayRun)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.DelayRunFromJSON: %w", err)
	}
	return result, nil
}

func DelayRunToJSON(x *DelayRun) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*DelayRun)(nil)
	_ json.Marshaler   = (*DelayRun)(nil)
)

func (r *DelayRun) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONDelayRun(*r)
}
func (r *DelayRun) _marshalJSONDelayRun(x DelayRun) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldDelayBySeconds []byte
	fieldDelayBySeconds, err = r._marshalJSONint64(x.DelayBySeconds)
	if err != nil {
		return nil, fmt.Errorf("workflow: DelayRun._marshalJSONDelayRun: field name DelayBySeconds; %w", err)
	}
	partial["DelayBySeconds"] = fieldDelayBySeconds
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: DelayRun._marshalJSONDelayRun: struct; %w", err)
	}
	return result, nil
}
func (r *DelayRun) _marshalJSONint64(x int64) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: DelayRun._marshalJSONint64:; %w", err)
	}
	return result, nil
}
func (r *DelayRun) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONDelayRun(data)
	if err != nil {
		return fmt.Errorf("workflow: DelayRun.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *DelayRun) _unmarshalJSONDelayRun(data []byte) (DelayRun, error) {
	result := DelayRun{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: DelayRun._unmarshalJSONDelayRun: native struct unwrap; %w", err)
	}
	if fieldDelayBySeconds, ok := partial["DelayBySeconds"]; ok {
		result.DelayBySeconds, err = r._unmarshalJSONint64(fieldDelayBySeconds)
		if err != nil {
			return result, fmt.Errorf("workflow: DelayRun._unmarshalJSONDelayRun: field DelayBySeconds; %w", err)
		}
	}
	return result, nil
}
func (r *DelayRun) _unmarshalJSONint64(data []byte) (int64, error) {
	var result int64
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: DelayRun._unmarshalJSONint64: native primitive unwrap; %w", err)
	}
	return result, nil
}

type StateVisitor interface {
	VisitNextOperation(v *NextOperation) any
	VisitDone(v *Done) any
	VisitError(v *Error) any
	VisitAwait(v *Await) any
	VisitScheduled(v *Scheduled) any
	VisitScheduleStopped(v *ScheduleStopped) any
}

type State interface {
	AcceptState(g StateVisitor) any
}

var (
	_ State = (*NextOperation)(nil)
	_ State = (*Done)(nil)
	_ State = (*Error)(nil)
	_ State = (*Await)(nil)
	_ State = (*Scheduled)(nil)
	_ State = (*ScheduleStopped)(nil)
)

func (r *NextOperation) AcceptState(v StateVisitor) any   { return v.VisitNextOperation(r) }
func (r *Done) AcceptState(v StateVisitor) any            { return v.VisitDone(r) }
func (r *Error) AcceptState(v StateVisitor) any           { return v.VisitError(r) }
func (r *Await) AcceptState(v StateVisitor) any           { return v.VisitAwait(r) }
func (r *Scheduled) AcceptState(v StateVisitor) any       { return v.VisitScheduled(r) }
func (r *ScheduleStopped) AcceptState(v StateVisitor) any { return v.VisitScheduleStopped(r) }

func MatchStateR3[T0, T1, T2 any](
	x State,
	f1 func(x *NextOperation) (T0, T1, T2),
	f2 func(x *Done) (T0, T1, T2),
	f3 func(x *Error) (T0, T1, T2),
	f4 func(x *Await) (T0, T1, T2),
	f5 func(x *Scheduled) (T0, T1, T2),
	f6 func(x *ScheduleStopped) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *NextOperation:
		return f1(v)
	case *Done:
		return f2(v)
	case *Error:
		return f3(v)
	case *Await:
		return f4(v)
	case *Scheduled:
		return f5(v)
	case *ScheduleStopped:
		return f6(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchStateR2[T0, T1 any](
	x State,
	f1 func(x *NextOperation) (T0, T1),
	f2 func(x *Done) (T0, T1),
	f3 func(x *Error) (T0, T1),
	f4 func(x *Await) (T0, T1),
	f5 func(x *Scheduled) (T0, T1),
	f6 func(x *ScheduleStopped) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *NextOperation:
		return f1(v)
	case *Done:
		return f2(v)
	case *Error:
		return f3(v)
	case *Await:
		return f4(v)
	case *Scheduled:
		return f5(v)
	case *ScheduleStopped:
		return f6(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchStateR1[T0 any](
	x State,
	f1 func(x *NextOperation) T0,
	f2 func(x *Done) T0,
	f3 func(x *Error) T0,
	f4 func(x *Await) T0,
	f5 func(x *Scheduled) T0,
	f6 func(x *ScheduleStopped) T0,
) T0 {
	switch v := x.(type) {
	case *NextOperation:
		return f1(v)
	case *Done:
		return f2(v)
	case *Error:
		return f3(v)
	case *Await:
		return f4(v)
	case *Scheduled:
		return f5(v)
	case *ScheduleStopped:
		return f6(v)
	}
	var result1 T0
	return result1
}

func MatchStateR0(
	x State,
	f1 func(x *NextOperation),
	f2 func(x *Done),
	f3 func(x *Error),
	f4 func(x *Await),
	f5 func(x *Scheduled),
	f6 func(x *ScheduleStopped),
) {
	switch v := x.(type) {
	case *NextOperation:
		f1(v)
	case *Done:
		f2(v)
	case *Error:
		f3(v)
	case *Await:
		f4(v)
	case *Scheduled:
		f5(v)
	case *ScheduleStopped:
		f6(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Await", AwaitFromJSON, AwaitToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Done", DoneFromJSON, DoneToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Error", ErrorFromJSON, ErrorToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.NextOperation", NextOperationFromJSON, NextOperationToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.ScheduleStopped", ScheduleStoppedFromJSON, ScheduleStoppedToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Scheduled", ScheduledFromJSON, ScheduledToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.State", StateFromJSON, StateToJSON)
}

type StateUnionJSON struct {
	Type            string          `json:"question_type,omitempty"`
	NextOperation   json.RawMessage `json:"workflow.NextOperation,omitempty"`
	Done            json.RawMessage `json:"workflow.Done,omitempty"`
	Error           json.RawMessage `json:"workflow.Error,omitempty"`
	Await           json.RawMessage `json:"workflow.Await,omitempty"`
	Scheduled       json.RawMessage `json:"workflow.Scheduled,omitempty"`
	ScheduleStopped json.RawMessage `json:"workflow.ScheduleStopped,omitempty"`
}

func StateFromJSON(x []byte) (State, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data StateUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("workflow.StateFromJSON: %w", err)
	}

	switch data.Type {
	case "workflow.NextOperation":
		return NextOperationFromJSON(data.NextOperation)
	case "workflow.Done":
		return DoneFromJSON(data.Done)
	case "workflow.Error":
		return ErrorFromJSON(data.Error)
	case "workflow.Await":
		return AwaitFromJSON(data.Await)
	case "workflow.Scheduled":
		return ScheduledFromJSON(data.Scheduled)
	case "workflow.ScheduleStopped":
		return ScheduleStoppedFromJSON(data.ScheduleStopped)
	}

	if data.NextOperation != nil {
		return NextOperationFromJSON(data.NextOperation)
	} else if data.Done != nil {
		return DoneFromJSON(data.Done)
	} else if data.Error != nil {
		return ErrorFromJSON(data.Error)
	} else if data.Await != nil {
		return AwaitFromJSON(data.Await)
	} else if data.Scheduled != nil {
		return ScheduledFromJSON(data.Scheduled)
	} else if data.ScheduleStopped != nil {
		return ScheduleStoppedFromJSON(data.ScheduleStopped)
	}
	return nil, fmt.Errorf("workflow.StateFromJSON: unknown type: %s", data.Type)
}

func StateToJSON(x State) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchStateR2(
		x,
		func(y *NextOperation) ([]byte, error) {
			body, err := NextOperationToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.StateToJSON: %w", err)
			}
			return json.Marshal(StateUnionJSON{
				Type:          "workflow.NextOperation",
				NextOperation: body,
			})
		},
		func(y *Done) ([]byte, error) {
			body, err := DoneToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.StateToJSON: %w", err)
			}
			return json.Marshal(StateUnionJSON{
				Type: "workflow.Done",
				Done: body,
			})
		},
		func(y *Error) ([]byte, error) {
			body, err := ErrorToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.StateToJSON: %w", err)
			}
			return json.Marshal(StateUnionJSON{
				Type:  "workflow.Error",
				Error: body,
			})
		},
		func(y *Await) ([]byte, error) {
			body, err := AwaitToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.StateToJSON: %w", err)
			}
			return json.Marshal(StateUnionJSON{
				Type:  "workflow.Await",
				Await: body,
			})
		},
		func(y *Scheduled) ([]byte, error) {
			body, err := ScheduledToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.StateToJSON: %w", err)
			}
			return json.Marshal(StateUnionJSON{
				Type:      "workflow.Scheduled",
				Scheduled: body,
			})
		},
		func(y *ScheduleStopped) ([]byte, error) {
			body, err := ScheduleStoppedToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.StateToJSON: %w", err)
			}
			return json.Marshal(StateUnionJSON{
				Type:            "workflow.ScheduleStopped",
				ScheduleStopped: body,
			})
		},
	)
}

func NextOperationFromJSON(x []byte) (*NextOperation, error) {
	result := new(NextOperation)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.NextOperationFromJSON: %w", err)
	}
	return result, nil
}

func NextOperationToJSON(x *NextOperation) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*NextOperation)(nil)
	_ json.Marshaler   = (*NextOperation)(nil)
)

func (r *NextOperation) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONNextOperation(*r)
}
func (r *NextOperation) _marshalJSONNextOperation(x NextOperation) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldResult []byte
	fieldResult, err = r._marshalJSONschema_Schema(x.Result)
	if err != nil {
		return nil, fmt.Errorf("workflow: NextOperation._marshalJSONNextOperation: field name Result; %w", err)
	}
	partial["Result"] = fieldResult
	var fieldBaseState []byte
	fieldBaseState, err = r._marshalJSONBaseState(x.BaseState)
	if err != nil {
		return nil, fmt.Errorf("workflow: NextOperation._marshalJSONNextOperation: field name BaseState; %w", err)
	}
	partial["BaseState"] = fieldBaseState
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: NextOperation._marshalJSONNextOperation: struct; %w", err)
	}
	return result, nil
}
func (r *NextOperation) _marshalJSONschema_Schema(x schema.Schema) ([]byte, error) {
	result, err := shared.JSONMarshal[schema.Schema](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: NextOperation._marshalJSONschema_Schema:; %w", err)
	}
	return result, nil
}
func (r *NextOperation) _marshalJSONBaseState(x BaseState) ([]byte, error) {
	result, err := shared.JSONMarshal[BaseState](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: NextOperation._marshalJSONBaseState:; %w", err)
	}
	return result, nil
}
func (r *NextOperation) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONNextOperation(data)
	if err != nil {
		return fmt.Errorf("workflow: NextOperation.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *NextOperation) _unmarshalJSONNextOperation(data []byte) (NextOperation, error) {
	result := NextOperation{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: NextOperation._unmarshalJSONNextOperation: native struct unwrap; %w", err)
	}
	if fieldResult, ok := partial["Result"]; ok {
		result.Result, err = r._unmarshalJSONschema_Schema(fieldResult)
		if err != nil {
			return result, fmt.Errorf("workflow: NextOperation._unmarshalJSONNextOperation: field Result; %w", err)
		}
	}
	if fieldBaseState, ok := partial["BaseState"]; ok {
		result.BaseState, err = r._unmarshalJSONBaseState(fieldBaseState)
		if err != nil {
			return result, fmt.Errorf("workflow: NextOperation._unmarshalJSONNextOperation: field BaseState; %w", err)
		}
	}
	return result, nil
}
func (r *NextOperation) _unmarshalJSONschema_Schema(data []byte) (schema.Schema, error) {
	result, err := shared.JSONUnmarshal[schema.Schema](data)
	if err != nil {
		return result, fmt.Errorf("workflow: NextOperation._unmarshalJSONschema_Schema: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *NextOperation) _unmarshalJSONBaseState(data []byte) (BaseState, error) {
	result, err := shared.JSONUnmarshal[BaseState](data)
	if err != nil {
		return result, fmt.Errorf("workflow: NextOperation._unmarshalJSONBaseState: native ref unwrap; %w", err)
	}
	return result, nil
}

func DoneFromJSON(x []byte) (*Done, error) {
	result := new(Done)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.DoneFromJSON: %w", err)
	}
	return result, nil
}

func DoneToJSON(x *Done) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Done)(nil)
	_ json.Marshaler   = (*Done)(nil)
)

func (r *Done) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONDone(*r)
}
func (r *Done) _marshalJSONDone(x Done) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldResult []byte
	fieldResult, err = r._marshalJSONschema_Schema(x.Result)
	if err != nil {
		return nil, fmt.Errorf("workflow: Done._marshalJSONDone: field name Result; %w", err)
	}
	partial["Result"] = fieldResult
	var fieldBaseState []byte
	fieldBaseState, err = r._marshalJSONBaseState(x.BaseState)
	if err != nil {
		return nil, fmt.Errorf("workflow: Done._marshalJSONDone: field name BaseState; %w", err)
	}
	partial["BaseState"] = fieldBaseState
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Done._marshalJSONDone: struct; %w", err)
	}
	return result, nil
}
func (r *Done) _marshalJSONschema_Schema(x schema.Schema) ([]byte, error) {
	result, err := shared.JSONMarshal[schema.Schema](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Done._marshalJSONschema_Schema:; %w", err)
	}
	return result, nil
}
func (r *Done) _marshalJSONBaseState(x BaseState) ([]byte, error) {
	result, err := shared.JSONMarshal[BaseState](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Done._marshalJSONBaseState:; %w", err)
	}
	return result, nil
}
func (r *Done) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONDone(data)
	if err != nil {
		return fmt.Errorf("workflow: Done.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Done) _unmarshalJSONDone(data []byte) (Done, error) {
	result := Done{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Done._unmarshalJSONDone: native struct unwrap; %w", err)
	}
	if fieldResult, ok := partial["Result"]; ok {
		result.Result, err = r._unmarshalJSONschema_Schema(fieldResult)
		if err != nil {
			return result, fmt.Errorf("workflow: Done._unmarshalJSONDone: field Result; %w", err)
		}
	}
	if fieldBaseState, ok := partial["BaseState"]; ok {
		result.BaseState, err = r._unmarshalJSONBaseState(fieldBaseState)
		if err != nil {
			return result, fmt.Errorf("workflow: Done._unmarshalJSONDone: field BaseState; %w", err)
		}
	}
	return result, nil
}
func (r *Done) _unmarshalJSONschema_Schema(data []byte) (schema.Schema, error) {
	result, err := shared.JSONUnmarshal[schema.Schema](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Done._unmarshalJSONschema_Schema: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *Done) _unmarshalJSONBaseState(data []byte) (BaseState, error) {
	result, err := shared.JSONUnmarshal[BaseState](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Done._unmarshalJSONBaseState: native ref unwrap; %w", err)
	}
	return result, nil
}

func ErrorFromJSON(x []byte) (*Error, error) {
	result := new(Error)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.ErrorFromJSON: %w", err)
	}
	return result, nil
}

func ErrorToJSON(x *Error) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Error)(nil)
	_ json.Marshaler   = (*Error)(nil)
)

func (r *Error) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONError(*r)
}
func (r *Error) _marshalJSONError(x Error) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldCode []byte
	fieldCode, err = r._marshalJSONstring(x.Code)
	if err != nil {
		return nil, fmt.Errorf("workflow: Error._marshalJSONError: field name Code; %w", err)
	}
	partial["Code"] = fieldCode
	var fieldReason []byte
	fieldReason, err = r._marshalJSONstring(x.Reason)
	if err != nil {
		return nil, fmt.Errorf("workflow: Error._marshalJSONError: field name Reason; %w", err)
	}
	partial["Reason"] = fieldReason
	var fieldRetried []byte
	fieldRetried, err = r._marshalJSONint64(x.Retried)
	if err != nil {
		return nil, fmt.Errorf("workflow: Error._marshalJSONError: field name Retried; %w", err)
	}
	partial["Retried"] = fieldRetried
	var fieldBaseState []byte
	fieldBaseState, err = r._marshalJSONBaseState(x.BaseState)
	if err != nil {
		return nil, fmt.Errorf("workflow: Error._marshalJSONError: field name BaseState; %w", err)
	}
	partial["BaseState"] = fieldBaseState
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Error._marshalJSONError: struct; %w", err)
	}
	return result, nil
}
func (r *Error) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Error._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Error) _marshalJSONint64(x int64) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Error._marshalJSONint64:; %w", err)
	}
	return result, nil
}
func (r *Error) _marshalJSONBaseState(x BaseState) ([]byte, error) {
	result, err := shared.JSONMarshal[BaseState](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Error._marshalJSONBaseState:; %w", err)
	}
	return result, nil
}
func (r *Error) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONError(data)
	if err != nil {
		return fmt.Errorf("workflow: Error.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Error) _unmarshalJSONError(data []byte) (Error, error) {
	result := Error{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Error._unmarshalJSONError: native struct unwrap; %w", err)
	}
	if fieldCode, ok := partial["Code"]; ok {
		result.Code, err = r._unmarshalJSONstring(fieldCode)
		if err != nil {
			return result, fmt.Errorf("workflow: Error._unmarshalJSONError: field Code; %w", err)
		}
	}
	if fieldReason, ok := partial["Reason"]; ok {
		result.Reason, err = r._unmarshalJSONstring(fieldReason)
		if err != nil {
			return result, fmt.Errorf("workflow: Error._unmarshalJSONError: field Reason; %w", err)
		}
	}
	if fieldRetried, ok := partial["Retried"]; ok {
		result.Retried, err = r._unmarshalJSONint64(fieldRetried)
		if err != nil {
			return result, fmt.Errorf("workflow: Error._unmarshalJSONError: field Retried; %w", err)
		}
	}
	if fieldBaseState, ok := partial["BaseState"]; ok {
		result.BaseState, err = r._unmarshalJSONBaseState(fieldBaseState)
		if err != nil {
			return result, fmt.Errorf("workflow: Error._unmarshalJSONError: field BaseState; %w", err)
		}
	}
	return result, nil
}
func (r *Error) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Error._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *Error) _unmarshalJSONint64(data []byte) (int64, error) {
	var result int64
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Error._unmarshalJSONint64: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *Error) _unmarshalJSONBaseState(data []byte) (BaseState, error) {
	result, err := shared.JSONUnmarshal[BaseState](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Error._unmarshalJSONBaseState: native ref unwrap; %w", err)
	}
	return result, nil
}

func AwaitFromJSON(x []byte) (*Await, error) {
	result := new(Await)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.AwaitFromJSON: %w", err)
	}
	return result, nil
}

func AwaitToJSON(x *Await) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Await)(nil)
	_ json.Marshaler   = (*Await)(nil)
)

func (r *Await) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAwait(*r)
}
func (r *Await) _marshalJSONAwait(x Await) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldCallbackID []byte
	fieldCallbackID, err = r._marshalJSONstring(x.CallbackID)
	if err != nil {
		return nil, fmt.Errorf("workflow: Await._marshalJSONAwait: field name CallbackID; %w", err)
	}
	partial["CallbackID"] = fieldCallbackID
	var fieldExpectedTimeoutTimestamp []byte
	fieldExpectedTimeoutTimestamp, err = r._marshalJSONint64(x.ExpectedTimeoutTimestamp)
	if err != nil {
		return nil, fmt.Errorf("workflow: Await._marshalJSONAwait: field name ExpectedTimeoutTimestamp; %w", err)
	}
	partial["ExpectedTimeoutTimestamp"] = fieldExpectedTimeoutTimestamp
	var fieldBaseState []byte
	fieldBaseState, err = r._marshalJSONBaseState(x.BaseState)
	if err != nil {
		return nil, fmt.Errorf("workflow: Await._marshalJSONAwait: field name BaseState; %w", err)
	}
	partial["BaseState"] = fieldBaseState
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Await._marshalJSONAwait: struct; %w", err)
	}
	return result, nil
}
func (r *Await) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Await._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Await) _marshalJSONint64(x int64) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Await._marshalJSONint64:; %w", err)
	}
	return result, nil
}
func (r *Await) _marshalJSONBaseState(x BaseState) ([]byte, error) {
	result, err := shared.JSONMarshal[BaseState](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Await._marshalJSONBaseState:; %w", err)
	}
	return result, nil
}
func (r *Await) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAwait(data)
	if err != nil {
		return fmt.Errorf("workflow: Await.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Await) _unmarshalJSONAwait(data []byte) (Await, error) {
	result := Await{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Await._unmarshalJSONAwait: native struct unwrap; %w", err)
	}
	if fieldCallbackID, ok := partial["CallbackID"]; ok {
		result.CallbackID, err = r._unmarshalJSONstring(fieldCallbackID)
		if err != nil {
			return result, fmt.Errorf("workflow: Await._unmarshalJSONAwait: field CallbackID; %w", err)
		}
	}
	if fieldExpectedTimeoutTimestamp, ok := partial["ExpectedTimeoutTimestamp"]; ok {
		result.ExpectedTimeoutTimestamp, err = r._unmarshalJSONint64(fieldExpectedTimeoutTimestamp)
		if err != nil {
			return result, fmt.Errorf("workflow: Await._unmarshalJSONAwait: field ExpectedTimeoutTimestamp; %w", err)
		}
	}
	if fieldBaseState, ok := partial["BaseState"]; ok {
		result.BaseState, err = r._unmarshalJSONBaseState(fieldBaseState)
		if err != nil {
			return result, fmt.Errorf("workflow: Await._unmarshalJSONAwait: field BaseState; %w", err)
		}
	}
	return result, nil
}
func (r *Await) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Await._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *Await) _unmarshalJSONint64(data []byte) (int64, error) {
	var result int64
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Await._unmarshalJSONint64: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *Await) _unmarshalJSONBaseState(data []byte) (BaseState, error) {
	result, err := shared.JSONUnmarshal[BaseState](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Await._unmarshalJSONBaseState: native ref unwrap; %w", err)
	}
	return result, nil
}

func ScheduledFromJSON(x []byte) (*Scheduled, error) {
	result := new(Scheduled)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.ScheduledFromJSON: %w", err)
	}
	return result, nil
}

func ScheduledToJSON(x *Scheduled) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Scheduled)(nil)
	_ json.Marshaler   = (*Scheduled)(nil)
)

func (r *Scheduled) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONScheduled(*r)
}
func (r *Scheduled) _marshalJSONScheduled(x Scheduled) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldExpectedRunTimestamp []byte
	fieldExpectedRunTimestamp, err = r._marshalJSONint64(x.ExpectedRunTimestamp)
	if err != nil {
		return nil, fmt.Errorf("workflow: Scheduled._marshalJSONScheduled: field name ExpectedRunTimestamp; %w", err)
	}
	partial["ExpectedRunTimestamp"] = fieldExpectedRunTimestamp
	var fieldBaseState []byte
	fieldBaseState, err = r._marshalJSONBaseState(x.BaseState)
	if err != nil {
		return nil, fmt.Errorf("workflow: Scheduled._marshalJSONScheduled: field name BaseState; %w", err)
	}
	partial["BaseState"] = fieldBaseState
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Scheduled._marshalJSONScheduled: struct; %w", err)
	}
	return result, nil
}
func (r *Scheduled) _marshalJSONint64(x int64) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Scheduled._marshalJSONint64:; %w", err)
	}
	return result, nil
}
func (r *Scheduled) _marshalJSONBaseState(x BaseState) ([]byte, error) {
	result, err := shared.JSONMarshal[BaseState](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Scheduled._marshalJSONBaseState:; %w", err)
	}
	return result, nil
}
func (r *Scheduled) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONScheduled(data)
	if err != nil {
		return fmt.Errorf("workflow: Scheduled.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Scheduled) _unmarshalJSONScheduled(data []byte) (Scheduled, error) {
	result := Scheduled{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Scheduled._unmarshalJSONScheduled: native struct unwrap; %w", err)
	}
	if fieldExpectedRunTimestamp, ok := partial["ExpectedRunTimestamp"]; ok {
		result.ExpectedRunTimestamp, err = r._unmarshalJSONint64(fieldExpectedRunTimestamp)
		if err != nil {
			return result, fmt.Errorf("workflow: Scheduled._unmarshalJSONScheduled: field ExpectedRunTimestamp; %w", err)
		}
	}
	if fieldBaseState, ok := partial["BaseState"]; ok {
		result.BaseState, err = r._unmarshalJSONBaseState(fieldBaseState)
		if err != nil {
			return result, fmt.Errorf("workflow: Scheduled._unmarshalJSONScheduled: field BaseState; %w", err)
		}
	}
	return result, nil
}
func (r *Scheduled) _unmarshalJSONint64(data []byte) (int64, error) {
	var result int64
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Scheduled._unmarshalJSONint64: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *Scheduled) _unmarshalJSONBaseState(data []byte) (BaseState, error) {
	result, err := shared.JSONUnmarshal[BaseState](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Scheduled._unmarshalJSONBaseState: native ref unwrap; %w", err)
	}
	return result, nil
}

func ScheduleStoppedFromJSON(x []byte) (*ScheduleStopped, error) {
	result := new(ScheduleStopped)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.ScheduleStoppedFromJSON: %w", err)
	}
	return result, nil
}

func ScheduleStoppedToJSON(x *ScheduleStopped) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*ScheduleStopped)(nil)
	_ json.Marshaler   = (*ScheduleStopped)(nil)
)

func (r *ScheduleStopped) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONScheduleStopped(*r)
}
func (r *ScheduleStopped) _marshalJSONScheduleStopped(x ScheduleStopped) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldBaseState []byte
	fieldBaseState, err = r._marshalJSONBaseState(x.BaseState)
	if err != nil {
		return nil, fmt.Errorf("workflow: ScheduleStopped._marshalJSONScheduleStopped: field name BaseState; %w", err)
	}
	partial["BaseState"] = fieldBaseState
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: ScheduleStopped._marshalJSONScheduleStopped: struct; %w", err)
	}
	return result, nil
}
func (r *ScheduleStopped) _marshalJSONBaseState(x BaseState) ([]byte, error) {
	result, err := shared.JSONMarshal[BaseState](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: ScheduleStopped._marshalJSONBaseState:; %w", err)
	}
	return result, nil
}
func (r *ScheduleStopped) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONScheduleStopped(data)
	if err != nil {
		return fmt.Errorf("workflow: ScheduleStopped.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *ScheduleStopped) _unmarshalJSONScheduleStopped(data []byte) (ScheduleStopped, error) {
	result := ScheduleStopped{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: ScheduleStopped._unmarshalJSONScheduleStopped: native struct unwrap; %w", err)
	}
	if fieldBaseState, ok := partial["BaseState"]; ok {
		result.BaseState, err = r._unmarshalJSONBaseState(fieldBaseState)
		if err != nil {
			return result, fmt.Errorf("workflow: ScheduleStopped._unmarshalJSONScheduleStopped: field BaseState; %w", err)
		}
	}
	return result, nil
}
func (r *ScheduleStopped) _unmarshalJSONBaseState(data []byte) (BaseState, error) {
	result, err := shared.JSONUnmarshal[BaseState](data)
	if err != nil {
		return result, fmt.Errorf("workflow: ScheduleStopped._unmarshalJSONBaseState: native ref unwrap; %w", err)
	}
	return result, nil
}

type WorkflowVisitor interface {
	VisitFlow(v *Flow) any
	VisitFlowRef(v *FlowRef) any
}

type Workflow interface {
	AcceptWorkflow(g WorkflowVisitor) any
}

var (
	_ Workflow = (*Flow)(nil)
	_ Workflow = (*FlowRef)(nil)
)

func (r *Flow) AcceptWorkflow(v WorkflowVisitor) any    { return v.VisitFlow(r) }
func (r *FlowRef) AcceptWorkflow(v WorkflowVisitor) any { return v.VisitFlowRef(r) }

func MatchWorkflowR3[T0, T1, T2 any](
	x Workflow,
	f1 func(x *Flow) (T0, T1, T2),
	f2 func(x *FlowRef) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *Flow:
		return f1(v)
	case *FlowRef:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchWorkflowR2[T0, T1 any](
	x Workflow,
	f1 func(x *Flow) (T0, T1),
	f2 func(x *FlowRef) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *Flow:
		return f1(v)
	case *FlowRef:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchWorkflowR1[T0 any](
	x Workflow,
	f1 func(x *Flow) T0,
	f2 func(x *FlowRef) T0,
) T0 {
	switch v := x.(type) {
	case *Flow:
		return f1(v)
	case *FlowRef:
		return f2(v)
	}
	var result1 T0
	return result1
}

func MatchWorkflowR0(
	x Workflow,
	f1 func(x *Flow),
	f2 func(x *FlowRef),
) {
	switch v := x.(type) {
	case *Flow:
		f1(v)
	case *FlowRef:
		f2(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Flow", FlowFromJSON, FlowToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.FlowRef", FlowRefFromJSON, FlowRefToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Workflow", WorkflowFromJSON, WorkflowToJSON)
}

type WorkflowUnionJSON struct {
	Type    string          `json:"question_type,omitempty"`
	Flow    json.RawMessage `json:"workflow.Flow,omitempty"`
	FlowRef json.RawMessage `json:"workflow.FlowRef,omitempty"`
}

func WorkflowFromJSON(x []byte) (Workflow, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data WorkflowUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("workflow.WorkflowFromJSON: %w", err)
	}

	switch data.Type {
	case "workflow.Flow":
		return FlowFromJSON(data.Flow)
	case "workflow.FlowRef":
		return FlowRefFromJSON(data.FlowRef)
	}

	if data.Flow != nil {
		return FlowFromJSON(data.Flow)
	} else if data.FlowRef != nil {
		return FlowRefFromJSON(data.FlowRef)
	}
	return nil, fmt.Errorf("workflow.WorkflowFromJSON: unknown type: %s", data.Type)
}

func WorkflowToJSON(x Workflow) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchWorkflowR2(
		x,
		func(y *Flow) ([]byte, error) {
			body, err := FlowToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.WorkflowToJSON: %w", err)
			}
			return json.Marshal(WorkflowUnionJSON{
				Type: "workflow.Flow",
				Flow: body,
			})
		},
		func(y *FlowRef) ([]byte, error) {
			body, err := FlowRefToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.WorkflowToJSON: %w", err)
			}
			return json.Marshal(WorkflowUnionJSON{
				Type:    "workflow.FlowRef",
				FlowRef: body,
			})
		},
	)
}

func FlowFromJSON(x []byte) (*Flow, error) {
	result := new(Flow)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.FlowFromJSON: %w", err)
	}
	return result, nil
}

func FlowToJSON(x *Flow) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Flow)(nil)
	_ json.Marshaler   = (*Flow)(nil)
)

func (r *Flow) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONFlow(*r)
}
func (r *Flow) _marshalJSONFlow(x Flow) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldName []byte
	fieldName, err = r._marshalJSONstring(x.Name)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONFlow: field name Name; %w", err)
	}
	partial["Name"] = fieldName
	var fieldArg []byte
	fieldArg, err = r._marshalJSONstring(x.Arg)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONFlow: field name Arg; %w", err)
	}
	partial["Arg"] = fieldArg
	var fieldBody []byte
	fieldBody, err = r._marshalJSONSliceExpr(x.Body)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONFlow: field name Body; %w", err)
	}
	partial["Body"] = fieldBody
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONFlow: struct; %w", err)
	}
	return result, nil
}
func (r *Flow) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Flow) _marshalJSONSliceExpr(x []Expr) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONExpr(v)
		if err != nil {
			return nil, fmt.Errorf("workflow: Flow._marshalJSONSliceExpr: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONSliceExpr:; %w", err)
	}
	return result, nil
}
func (r *Flow) _marshalJSONExpr(x Expr) ([]byte, error) {
	result, err := shared.JSONMarshal[Expr](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONExpr:; %w", err)
	}
	return result, nil
}
func (r *Flow) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONFlow(data)
	if err != nil {
		return fmt.Errorf("workflow: Flow.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Flow) _unmarshalJSONFlow(data []byte) (Flow, error) {
	result := Flow{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Flow._unmarshalJSONFlow: native struct unwrap; %w", err)
	}
	if fieldName, ok := partial["Name"]; ok {
		result.Name, err = r._unmarshalJSONstring(fieldName)
		if err != nil {
			return result, fmt.Errorf("workflow: Flow._unmarshalJSONFlow: field Name; %w", err)
		}
	}
	if fieldArg, ok := partial["Arg"]; ok {
		result.Arg, err = r._unmarshalJSONstring(fieldArg)
		if err != nil {
			return result, fmt.Errorf("workflow: Flow._unmarshalJSONFlow: field Arg; %w", err)
		}
	}
	if fieldBody, ok := partial["Body"]; ok {
		result.Body, err = r._unmarshalJSONSliceExpr(fieldBody)
		if err != nil {
			return result, fmt.Errorf("workflow: Flow._unmarshalJSONFlow: field Body; %w", err)
		}
	}
	return result, nil
}
func (r *Flow) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Flow._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *Flow) _unmarshalJSONSliceExpr(data []byte) ([]Expr, error) {
	result := make([]Expr, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Flow._unmarshalJSONSliceExpr: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONExpr(v)
		if err != nil {
			return result, fmt.Errorf("workflow: Flow._unmarshalJSONSliceExpr: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *Flow) _unmarshalJSONExpr(data []byte) (Expr, error) {
	result, err := shared.JSONUnmarshal[Expr](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Flow._unmarshalJSONExpr: native ref unwrap; %w", err)
	}
	return result, nil
}

func FlowRefFromJSON(x []byte) (*FlowRef, error) {
	result := new(FlowRef)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.FlowRefFromJSON: %w", err)
	}
	return result, nil
}

func FlowRefToJSON(x *FlowRef) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*FlowRef)(nil)
	_ json.Marshaler   = (*FlowRef)(nil)
)

func (r *FlowRef) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONFlowRef(*r)
}
func (r *FlowRef) _marshalJSONFlowRef(x FlowRef) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldFlowID []byte
	fieldFlowID, err = r._marshalJSONstring(x.FlowID)
	if err != nil {
		return nil, fmt.Errorf("workflow: FlowRef._marshalJSONFlowRef: field name FlowID; %w", err)
	}
	partial["FlowID"] = fieldFlowID
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: FlowRef._marshalJSONFlowRef: struct; %w", err)
	}
	return result, nil
}
func (r *FlowRef) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: FlowRef._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *FlowRef) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONFlowRef(data)
	if err != nil {
		return fmt.Errorf("workflow: FlowRef.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *FlowRef) _unmarshalJSONFlowRef(data []byte) (FlowRef, error) {
	result := FlowRef{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: FlowRef._unmarshalJSONFlowRef: native struct unwrap; %w", err)
	}
	if fieldFlowID, ok := partial["FlowID"]; ok {
		result.FlowID, err = r._unmarshalJSONstring(fieldFlowID)
		if err != nil {
			return result, fmt.Errorf("workflow: FlowRef._unmarshalJSONFlowRef: field FlowID; %w", err)
		}
	}
	return result, nil
}
func (r *FlowRef) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: FlowRef._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
