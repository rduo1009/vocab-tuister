// Code generated by "enumer -type=Number,Tense,Voice,Mood,Case,Gender,Degree -transform=snake -output client/pkg/enums/ending_components_enumer_gen.go client/pkg/enums/ending_components.go"; DO NOT EDIT.

package enums

import (
	"fmt"
	"strings"
)

const _NumberName = "singularplural"

var _NumberIndex = [...]uint8{0, 8, 14}

const _NumberLowerName = "singularplural"

func (i Number) String() string {
	if i < 0 || i >= Number(len(_NumberIndex)-1) {
		return fmt.Sprintf("Number(%d)", i)
	}
	return _NumberName[_NumberIndex[i]:_NumberIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _NumberNoOp() {
	var x [1]struct{}
	_ = x[Singular-(0)]
	_ = x[Plural-(1)]
}

var _NumberValues = []Number{Singular, Plural}

var _NumberNameToValueMap = map[string]Number{
	_NumberName[0:8]:       Singular,
	_NumberLowerName[0:8]:  Singular,
	_NumberName[8:14]:      Plural,
	_NumberLowerName[8:14]: Plural,
}

var _NumberNames = []string{
	_NumberName[0:8],
	_NumberName[8:14],
}

// NumberString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func NumberString(s string) (Number, error) {
	if val, ok := _NumberNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _NumberNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Number values", s)
}

// NumberValues returns all values of the enum
func NumberValues() []Number {
	return _NumberValues
}

// NumberStrings returns a slice of all String values of the enum
func NumberStrings() []string {
	strs := make([]string, len(_NumberNames))
	copy(strs, _NumberNames)
	return strs
}

// IsANumber returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Number) IsANumber() bool {
	for _, v := range _NumberValues {
		if i == v {
			return true
		}
	}
	return false
}

const _TenseName = "presentimperfectfutureperfectpluperfectfuture_perfect"

var _TenseIndex = [...]uint8{0, 7, 16, 22, 29, 39, 53}

const _TenseLowerName = "presentimperfectfutureperfectpluperfectfuture_perfect"

func (i Tense) String() string {
	if i < 0 || i >= Tense(len(_TenseIndex)-1) {
		return fmt.Sprintf("Tense(%d)", i)
	}
	return _TenseName[_TenseIndex[i]:_TenseIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _TenseNoOp() {
	var x [1]struct{}
	_ = x[Present-(0)]
	_ = x[Imperfect-(1)]
	_ = x[Future-(2)]
	_ = x[Perfect-(3)]
	_ = x[Pluperfect-(4)]
	_ = x[FuturePerfect-(5)]
}

var _TenseValues = []Tense{Present, Imperfect, Future, Perfect, Pluperfect, FuturePerfect}

var _TenseNameToValueMap = map[string]Tense{
	_TenseName[0:7]:        Present,
	_TenseLowerName[0:7]:   Present,
	_TenseName[7:16]:       Imperfect,
	_TenseLowerName[7:16]:  Imperfect,
	_TenseName[16:22]:      Future,
	_TenseLowerName[16:22]: Future,
	_TenseName[22:29]:      Perfect,
	_TenseLowerName[22:29]: Perfect,
	_TenseName[29:39]:      Pluperfect,
	_TenseLowerName[29:39]: Pluperfect,
	_TenseName[39:53]:      FuturePerfect,
	_TenseLowerName[39:53]: FuturePerfect,
}

var _TenseNames = []string{
	_TenseName[0:7],
	_TenseName[7:16],
	_TenseName[16:22],
	_TenseName[22:29],
	_TenseName[29:39],
	_TenseName[39:53],
}

// TenseString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func TenseString(s string) (Tense, error) {
	if val, ok := _TenseNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _TenseNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Tense values", s)
}

// TenseValues returns all values of the enum
func TenseValues() []Tense {
	return _TenseValues
}

// TenseStrings returns a slice of all String values of the enum
func TenseStrings() []string {
	strs := make([]string, len(_TenseNames))
	copy(strs, _TenseNames)
	return strs
}

// IsATense returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Tense) IsATense() bool {
	for _, v := range _TenseValues {
		if i == v {
			return true
		}
	}
	return false
}

const _VoiceName = "activepassive"

var _VoiceIndex = [...]uint8{0, 6, 13}

const _VoiceLowerName = "activepassive"

func (i Voice) String() string {
	if i < 0 || i >= Voice(len(_VoiceIndex)-1) {
		return fmt.Sprintf("Voice(%d)", i)
	}
	return _VoiceName[_VoiceIndex[i]:_VoiceIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _VoiceNoOp() {
	var x [1]struct{}
	_ = x[Active-(0)]
	_ = x[Passive-(1)]
}

var _VoiceValues = []Voice{Active, Passive}

var _VoiceNameToValueMap = map[string]Voice{
	_VoiceName[0:6]:       Active,
	_VoiceLowerName[0:6]:  Active,
	_VoiceName[6:13]:      Passive,
	_VoiceLowerName[6:13]: Passive,
}

var _VoiceNames = []string{
	_VoiceName[0:6],
	_VoiceName[6:13],
}

// VoiceString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func VoiceString(s string) (Voice, error) {
	if val, ok := _VoiceNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _VoiceNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Voice values", s)
}

// VoiceValues returns all values of the enum
func VoiceValues() []Voice {
	return _VoiceValues
}

// VoiceStrings returns a slice of all String values of the enum
func VoiceStrings() []string {
	strs := make([]string, len(_VoiceNames))
	copy(strs, _VoiceNames)
	return strs
}

// IsAVoice returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Voice) IsAVoice() bool {
	for _, v := range _VoiceValues {
		if i == v {
			return true
		}
	}
	return false
}

const _MoodName = "indicativeinfinitiveimperativesubjunctiveparticiple"

var _MoodIndex = [...]uint8{0, 10, 20, 30, 41, 51}

const _MoodLowerName = "indicativeinfinitiveimperativesubjunctiveparticiple"

func (i Mood) String() string {
	if i < 0 || i >= Mood(len(_MoodIndex)-1) {
		return fmt.Sprintf("Mood(%d)", i)
	}
	return _MoodName[_MoodIndex[i]:_MoodIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _MoodNoOp() {
	var x [1]struct{}
	_ = x[Indicative-(0)]
	_ = x[Infinitive-(1)]
	_ = x[Imperative-(2)]
	_ = x[Subjunctive-(3)]
	_ = x[Participle-(4)]
}

var _MoodValues = []Mood{Indicative, Infinitive, Imperative, Subjunctive, Participle}

var _MoodNameToValueMap = map[string]Mood{
	_MoodName[0:10]:       Indicative,
	_MoodLowerName[0:10]:  Indicative,
	_MoodName[10:20]:      Infinitive,
	_MoodLowerName[10:20]: Infinitive,
	_MoodName[20:30]:      Imperative,
	_MoodLowerName[20:30]: Imperative,
	_MoodName[30:41]:      Subjunctive,
	_MoodLowerName[30:41]: Subjunctive,
	_MoodName[41:51]:      Participle,
	_MoodLowerName[41:51]: Participle,
}

var _MoodNames = []string{
	_MoodName[0:10],
	_MoodName[10:20],
	_MoodName[20:30],
	_MoodName[30:41],
	_MoodName[41:51],
}

// MoodString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func MoodString(s string) (Mood, error) {
	if val, ok := _MoodNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _MoodNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Mood values", s)
}

// MoodValues returns all values of the enum
func MoodValues() []Mood {
	return _MoodValues
}

// MoodStrings returns a slice of all String values of the enum
func MoodStrings() []string {
	strs := make([]string, len(_MoodNames))
	copy(strs, _MoodNames)
	return strs
}

// IsAMood returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Mood) IsAMood() bool {
	for _, v := range _MoodValues {
		if i == v {
			return true
		}
	}
	return false
}

const _CaseName = "nominativevocativeaccusativegenitivedativeablative"

var _CaseIndex = [...]uint8{0, 10, 18, 28, 36, 42, 50}

const _CaseLowerName = "nominativevocativeaccusativegenitivedativeablative"

func (i Case) String() string {
	if i < 0 || i >= Case(len(_CaseIndex)-1) {
		return fmt.Sprintf("Case(%d)", i)
	}
	return _CaseName[_CaseIndex[i]:_CaseIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _CaseNoOp() {
	var x [1]struct{}
	_ = x[Nominative-(0)]
	_ = x[Vocative-(1)]
	_ = x[Accusative-(2)]
	_ = x[Genitive-(3)]
	_ = x[Dative-(4)]
	_ = x[Ablative-(5)]
}

var _CaseValues = []Case{Nominative, Vocative, Accusative, Genitive, Dative, Ablative}

var _CaseNameToValueMap = map[string]Case{
	_CaseName[0:10]:       Nominative,
	_CaseLowerName[0:10]:  Nominative,
	_CaseName[10:18]:      Vocative,
	_CaseLowerName[10:18]: Vocative,
	_CaseName[18:28]:      Accusative,
	_CaseLowerName[18:28]: Accusative,
	_CaseName[28:36]:      Genitive,
	_CaseLowerName[28:36]: Genitive,
	_CaseName[36:42]:      Dative,
	_CaseLowerName[36:42]: Dative,
	_CaseName[42:50]:      Ablative,
	_CaseLowerName[42:50]: Ablative,
}

var _CaseNames = []string{
	_CaseName[0:10],
	_CaseName[10:18],
	_CaseName[18:28],
	_CaseName[28:36],
	_CaseName[36:42],
	_CaseName[42:50],
}

// CaseString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func CaseString(s string) (Case, error) {
	if val, ok := _CaseNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _CaseNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Case values", s)
}

// CaseValues returns all values of the enum
func CaseValues() []Case {
	return _CaseValues
}

// CaseStrings returns a slice of all String values of the enum
func CaseStrings() []string {
	strs := make([]string, len(_CaseNames))
	copy(strs, _CaseNames)
	return strs
}

// IsACase returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Case) IsACase() bool {
	for _, v := range _CaseValues {
		if i == v {
			return true
		}
	}
	return false
}

const _GenderName = "masculinefeminineneuter"

var _GenderIndex = [...]uint8{0, 9, 17, 23}

const _GenderLowerName = "masculinefeminineneuter"

func (i Gender) String() string {
	if i < 0 || i >= Gender(len(_GenderIndex)-1) {
		return fmt.Sprintf("Gender(%d)", i)
	}
	return _GenderName[_GenderIndex[i]:_GenderIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _GenderNoOp() {
	var x [1]struct{}
	_ = x[Masculine-(0)]
	_ = x[Feminine-(1)]
	_ = x[Neuter-(2)]
}

var _GenderValues = []Gender{Masculine, Feminine, Neuter}

var _GenderNameToValueMap = map[string]Gender{
	_GenderName[0:9]:        Masculine,
	_GenderLowerName[0:9]:   Masculine,
	_GenderName[9:17]:       Feminine,
	_GenderLowerName[9:17]:  Feminine,
	_GenderName[17:23]:      Neuter,
	_GenderLowerName[17:23]: Neuter,
}

var _GenderNames = []string{
	_GenderName[0:9],
	_GenderName[9:17],
	_GenderName[17:23],
}

// GenderString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func GenderString(s string) (Gender, error) {
	if val, ok := _GenderNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _GenderNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Gender values", s)
}

// GenderValues returns all values of the enum
func GenderValues() []Gender {
	return _GenderValues
}

// GenderStrings returns a slice of all String values of the enum
func GenderStrings() []string {
	strs := make([]string, len(_GenderNames))
	copy(strs, _GenderNames)
	return strs
}

// IsAGender returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Gender) IsAGender() bool {
	for _, v := range _GenderValues {
		if i == v {
			return true
		}
	}
	return false
}

const _DegreeName = "positivecomparativesuperlative"

var _DegreeIndex = [...]uint8{0, 8, 19, 30}

const _DegreeLowerName = "positivecomparativesuperlative"

func (i Degree) String() string {
	if i < 0 || i >= Degree(len(_DegreeIndex)-1) {
		return fmt.Sprintf("Degree(%d)", i)
	}
	return _DegreeName[_DegreeIndex[i]:_DegreeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _DegreeNoOp() {
	var x [1]struct{}
	_ = x[Positive-(0)]
	_ = x[Comparative-(1)]
	_ = x[Superlative-(2)]
}

var _DegreeValues = []Degree{Positive, Comparative, Superlative}

var _DegreeNameToValueMap = map[string]Degree{
	_DegreeName[0:8]:        Positive,
	_DegreeLowerName[0:8]:   Positive,
	_DegreeName[8:19]:       Comparative,
	_DegreeLowerName[8:19]:  Comparative,
	_DegreeName[19:30]:      Superlative,
	_DegreeLowerName[19:30]: Superlative,
}

var _DegreeNames = []string{
	_DegreeName[0:8],
	_DegreeName[8:19],
	_DegreeName[19:30],
}

// DegreeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func DegreeString(s string) (Degree, error) {
	if val, ok := _DegreeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _DegreeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Degree values", s)
}

// DegreeValues returns all values of the enum
func DegreeValues() []Degree {
	return _DegreeValues
}

// DegreeStrings returns a slice of all String values of the enum
func DegreeStrings() []string {
	strs := make([]string, len(_DegreeNames))
	copy(strs, _DegreeNames)
	return strs
}

// IsADegree returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Degree) IsADegree() bool {
	for _, v := range _DegreeValues {
		if i == v {
			return true
		}
	}
	return false
}
